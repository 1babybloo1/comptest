<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poxel Competitive - Admin Panel</title>
    <!-- Basic Styling - Adapt or link your main CSS if desired -->
    <style>
        :root {
            --dark: #121212;
            --dark-accent: #1e1e1e;
            --orange: #ff5722;
            --text: #f5f5f5;
            --text-secondary: #aaaaaa;
        }
        body { background-color: var(--dark); color: var(--text); font-family: sans-serif; padding: 20px; }
        #login-container, #admin-panel { background-color: var(--dark-accent); padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        h1, h2 { color: var(--orange); }
        button { background-color: var(--orange); color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { opacity: 0.9; }
        #logout-button { background-color: #555; }
        .admin-section { margin-top: 20px; border-top: 1px solid #444; padding-top: 20px; }
        label { display: block; margin-bottom: 5px; color: var(--text-secondary); }
        input[type="text"], input[type="datetime-local"], input[type="number"], textarea {
            width: 95%; padding: 8px; margin-bottom: 10px; background-color: #333; border: 1px solid #555; color: var(--text); border-radius: 4px;
        }
        .hidden { display: none; }
        .fade-in { animation: fadeIn 0.5s ease forwards; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        th, td { border: 1px solid #444; padding: 8px; text-align: left; }
        th { background-color: rgba(255, 87, 34, 0.1); color: var(--orange); }
        .match-editor, .player-editor, .bracket-editor { margin-bottom: 15px; padding: 10px; border: 1px dashed #555; border-radius: 5px; }
        .bracket-round { margin-bottom: 10px; padding: 15px; border-left: 2px solid var(--orange); background-color: rgba(0,0,0,0.1); /* Added slight background */ }
        .bracket-match { margin-bottom: 10px; padding: 10px; border: 1px solid #444; border-radius: 4px; background-color: var(--dark-accent); }
        .matches-in-round { padding-top: 10px; }
    </style>
</head>
<body>

    <h1>Poxel Competitive - Admin</h1>

    <!-- Login Section -->
    <div id="login-container">
        <h2>Admin Login</h2>
        <p>Please log in with your authorized Google account.</p>
        <button id="login-button">Login with Google</button>
        <p id="login-error" style="color: red;"></p>
    </div>

    <!-- Admin Panel (Initially Hidden) -->
    <div id="admin-panel" class="hidden">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h2>Management Dashboard</h2>
            <div>
                <span id="user-info" style="margin-right: 15px;"></span>
                <button id="logout-button">Logout</button>
            </div>
        </div>
         <p style="color: lightgreen;" id="save-status"></p>

        <!-- Upcoming Matches Management -->
        <div class="admin-section">
            <h3>Upcoming Matches Management</h3>
            <div id="matches-list">
                <!-- Matches will be loaded here -->
            </div>
            <button id="add-match-button">Add New Match</button>
            <div id="add-match-form" class="match-editor hidden">
                 <h4>New Match Details</h4>
                 <label for="new-match-date">Date & Time:</label>
                 <input type="datetime-local" id="new-match-date">
                 <label for="new-match-type">Type (e.g., Quarterfinals):</label>
                 <input type="text" id="new-match-type">
                 <label for="new-match-team1-name">Team 1 Name:</label>
                 <input type="text" id="new-match-team1-name">
                 <label for="new-match-team1-logo">Team 1 Logo (Initials):</label>
                 <input type="text" id="new-match-team1-logo" maxlength="2">
                 <label for="new-match-team2-name">Team 2 Name:</label>
                 <input type="text" id="new-match-team2-name">
                 <label for="new-match-team2-logo">Team 2 Logo (Initials):</label>
                 <input type="text" id="new-match-team2-logo" maxlength="2">
                 <label for="new-match-venue">Venue:</label>
                 <input type="text" id="new-match-venue">
                 <label for="new-match-stream">Stream Link:</label>
                 <input type="text" id="new-match-stream" value="https://www.twitch.tv/poxelcompetitive/">
                 <button id="save-new-match">Save New Match</button>
                 <button type="button" onclick="document.getElementById('add-match-form').classList.add('hidden')">Cancel</button>
            </div>
            <button id="save-matches-changes">Save All Match Changes</button>
        </div>

        <!-- Leaderboard Management -->
        <div class="admin-section">
            <h3>Leaderboard Management</h3>
            <div id="leaderboard-list">
                 <table>
                     <thead>
                         <tr>
                             <th>Rank</th>
                             <th>Player Name</th>
                             <th>Avatar</th>
                             <th>Matches</th>
                             <th>Wins</th>
                             <th>Losses</th>
                             <th>Points</th>
                             <th>Actions</th>
                         </tr>
                     </thead>
                     <tbody id="leaderboard-body-admin">
                         <!-- Leaderboard entries loaded here -->
                     </tbody>
                 </table>
            </div>
             <button id="add-player-button">Add New Player</button>
             <div id="add-player-form" class="player-editor hidden">
                 <h4>New Player Details</h4>
                 <label>Name:</label><input type="text" id="new-player-name">
                 <label>Avatar (Initials):</label><input type="text" id="new-player-avatar" maxlength="2">
                 <label>Matches:</label><input type="number" id="new-player-matches" value="0">
                 <label>Wins:</label><input type="number" id="new-player-wins" value="0">
                 <label>Losses:</label><input type="number" id="new-player-losses" value="0">
                 <label>Points:</label><input type="number" id="new-player-points" value="0">
                 <button id="save-new-player">Save New Player</button>
                 <button type="button" onclick="document.getElementById('add-player-form').classList.add('hidden')">Cancel</button>
            </div>
            <button id="save-leaderboard-changes">Save Leaderboard Changes</button>
        </div>

        <!-- Tournament Bracket Management -->
        <div class="admin-section">
            <h3>Tournament Bracket Management</h3>
            <label for="bracket-select">Select Bracket:</label>
            <select id="bracket-select">
                <option value="pro">Pro Tourney</option>
                <option value="novice">Novice Tourney</option>
            </select>
            <div id="bracket-editor">
                <!-- Bracket editor UI will be loaded here -->
            </div>
            <button id="add-round-button">Add Round</button>
            <button id="save-bracket-changes">Save Bracket Changes</button>
             <p><i>Note: Bracket editing UI is simplified. Add rounds/matches below. Complex drag-and-drop requires significant JS.</i></p>
        </div>

    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

    <script>
        // --- START OF SCRIPT --- //

        // IMPORTANT: Firebase Config (Ensure this is correct)
        const firebaseConfig = {
             apiKey: "AIzaSyDWFPys8dbSgis98tbm5PVqMuHqnCpPIxI", // Replace if needed
             authDomain: "poxelcomp.firebaseapp.com", // Replace if needed
             projectId: "poxelcomp", // Replace if needed
             storageBucket: "poxelcomp.firebasestorage.app", // Replace if needed
             messagingSenderId: "620490990104", // Replace if needed
             appId: "1:620490990104:web:709023eb464c7d886b996d", // Replace if needed
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const googleProvider = new firebase.auth.GoogleAuthProvider();

        // DOM Elements (ensure all are correctly referenced)
        const loginContainer = document.getElementById('login-container');
        const adminPanel = document.getElementById('admin-panel');
        const loginButton = document.getElementById('login-button');
        const logoutButton = document.getElementById('logout-button');
        const userInfo = document.getElementById('user-info');
        const loginError = document.getElementById('login-error');
        const saveStatus = document.getElementById('save-status');

        const matchesList = document.getElementById('matches-list');
        const addMatchButton = document.getElementById('add-match-button');
        const addMatchForm = document.getElementById('add-match-form');
        const saveNewMatchButton = document.getElementById('save-new-match');
        const saveMatchesChangesButton = document.getElementById('save-matches-changes');

        const leaderboardList = document.getElementById('leaderboard-list');
        const leaderboardBodyAdmin = document.getElementById('leaderboard-body-admin');
        const addPlayerButton = document.getElementById('add-player-button');
        const addPlayerForm = document.getElementById('add-player-form');
        const saveNewPlayerButton = document.getElementById('save-new-player');
        const saveLeaderboardChangesButton = document.getElementById('save-leaderboard-changes');

        const bracketSelect = document.getElementById('bracket-select');
        const bracketEditor = document.getElementById('bracket-editor');
        const addRoundButton = document.getElementById('add-round-button');
        const saveBracketChangesButton = document.getElementById('save-bracket-changes');


        // --- Authentication ---
        auth.onAuthStateChanged(user => {
            if (user) {
                console.log("User signed in:", user.email);
                loginContainer.classList.add('hidden');
                adminPanel.classList.remove('hidden');
                adminPanel.classList.add('fade-in');
                userInfo.textContent = `Logged in as: ${user.displayName || user.email}`;
                loadAdminData(); // Load data once logged in
            } else {
                console.log("User signed out.");
                adminPanel.classList.add('hidden');
                adminPanel.classList.remove('fade-in');
                loginContainer.classList.remove('hidden');
                userInfo.textContent = '';
                 clearAdminUI(); // Clear data when logged out
            }
        });

        loginButton.addEventListener('click', () => {
            loginError.textContent = '';
            console.log("Attempting Google Sign-in...");
            auth.signInWithPopup(googleProvider)
                 .then((result) => {
                    console.log("Sign-in successful:", result.user);
                 })
                .catch((error) => {
                    console.error("Login failed:", error.code, error.message, error); // Log more error details
                    loginError.textContent = `Login failed: ${error.message}`;
                });
        });

        logoutButton.addEventListener('click', () => {
            console.log("Attempting Sign-out...");
            auth.signOut().then(() => console.log("Sign-out successful."));
        });

        function clearAdminUI() {
             console.log("Clearing Admin UI...");
            if (matchesList) matchesList.innerHTML = '';
            if (leaderboardBodyAdmin) leaderboardBodyAdmin.innerHTML = '';
            if (bracketEditor) bracketEditor.innerHTML = '';
            if (saveStatus) saveStatus.textContent = '';
             if (addMatchForm) addMatchForm.classList.add('hidden');
             if (addPlayerForm) addPlayerForm.classList.add('hidden');
        }

        // --- Data Loading ---
        function loadAdminData() {
             console.log("Loading all admin data...");
            loadMatchesAdmin();
            loadLeaderboardAdmin();
             if (bracketSelect) {
                loadBracketAdmin(bracketSelect.value);
             } else {
                 console.error("bracketSelect element not found during initial load.");
             }
        }

        async function loadMatchesAdmin() {
            if (!matchesList) { console.error("loadMatchesAdmin: matchesList element not found"); return; }
            matchesList.innerHTML = 'Loading matches...';
            console.log("Loading matches from Firestore...");
            try {
                const snapshot = await db.collection('matches').orderBy('date', 'desc').get();
                console.log(`Found ${snapshot.size} matches.`);
                matchesList.innerHTML = '';
                if (snapshot.empty) {
                    matchesList.innerHTML = '<p>No matches found.</p>';
                    return;
                }
                snapshot.forEach(doc => {
                    const match = { id: doc.id, ...doc.data() };
                    const dateForInput = match.date?.toDate ? new Date(match.date.toDate().getTime() - match.date.toDate().getTimezoneOffset() * 60000).toISOString().slice(0, 16) : '';
                    const matchDiv = document.createElement('div');
                    matchDiv.classList.add('match-editor');
                    matchDiv.dataset.id = match.id;
                     matchDiv.innerHTML = `
                         <h4>Match ID: ${match.id}</h4>
                         <label>Date:</label><input type="datetime-local" value="${dateForInput}" data-field="date">
                         <label>Type:</label><input type="text" value="${match.type || ''}" data-field="type">
                         <label>Team 1:</label><input type="text" value="${match.team1?.name || ''}" data-field="team1.name">
                         <label>Team 1 Logo:</label><input type="text" value="${match.team1?.logo || ''}" data-field="team1.logo" maxlength="2">
                         <label>Team 2:</label><input type="text" value="${match.team2?.name || ''}" data-field="team2.name">
                         <label>Team 2 Logo:</label><input type="text" value="${match.team2?.logo || ''}" data-field="team2.logo" maxlength="2">
                         <label>Venue:</label><input type="text" value="${match.venue || ''}" data-field="venue">
                         <label>Stream:</label><input type="text" value="${match.streamLink || ''}" data-field="streamLink">
                         <button class="delete-match-button" data-id="${match.id}">Delete Match</button>
                     `;
                    matchesList.appendChild(matchDiv);
                });
                 attachMatchDeleteListeners();

            } catch (error) {
                console.error("Error loading matches:", error);
                matchesList.innerHTML = '<p style="color:red;">Error loading matches.</p>';
            }
        }

        function attachMatchDeleteListeners() {
             document.querySelectorAll('#matches-list .delete-match-button').forEach(button => {
                 button.replaceWith(button.cloneNode(true));
             });
             document.querySelectorAll('#matches-list .delete-match-button').forEach(button => {
                 button.addEventListener('click', async (e) => {
                     const id = e.target.dataset.id;
                     console.log(`Attempting to delete match ID: ${id}`);
                     if (confirm(`Are you sure you want to delete match ${id}?`)) {
                         try {
                             await db.collection('matches').doc(id).delete();
                             console.log(`Match ${id} deleted.`);
                             showSaveStatus('Match deleted successfully!', false);
                             loadMatchesAdmin();
                         } catch (error) {
                             console.error("Error deleting match:", error);
                             showSaveStatus(`Error deleting match: ${error.message}`, true);
                         }
                     } else { console.log("Deletion cancelled."); }
                 });
             });
        }

         async function loadLeaderboardAdmin() {
             if (!leaderboardBodyAdmin) { console.error("loadLeaderboardAdmin: leaderboardBodyAdmin element not found"); return; }
            leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8">Loading leaderboard...</td></tr>';
             console.log("Loading leaderboard from Firestore...");
             try {
                 const snapshot = await db.collection('leaderboard').orderBy('points', 'desc').get();
                 console.log(`Found ${snapshot.size} players.`);
                 leaderboardBodyAdmin.innerHTML = '';
                 let rank = 1;
                 if (snapshot.empty) {
                     leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8">No players found.</td></tr>';
                     return;
                 }
                 snapshot.forEach(doc => {
                     const player = { id: doc.id, ...doc.data() };
                     const row = document.createElement('tr');
                     row.dataset.id = player.id;
                      row.innerHTML = `
                          <td>${rank++}</td>
                          <td><input type="text" value="${player.name || ''}" data-field="name"></td>
                          <td><input type="text" value="${player.avatar || ''}" data-field="avatar" maxlength="2"></td>
                          <td><input type="number" value="${player.matches || 0}" data-field="matches"></td>
                          <td><input type="number" value="${player.wins || 0}" data-field="wins"></td>
                          <td><input type="number" value="${player.losses || 0}" data-field="losses"></td>
                          <td><input type="number" value="${player.points || 0}" data-field="points"></td>
                           <td><button class="delete-player-button" data-id="${player.id}">Delete</button></td>
                      `;
                     leaderboardBodyAdmin.appendChild(row);
                 });
                 attachPlayerDeleteListeners();

             } catch (error) {
                 console.error("Error loading leaderboard:", error);
                 leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8" style="color:red;">Error loading leaderboard.</td></tr>';
             }
         }

         function attachPlayerDeleteListeners() {
             document.querySelectorAll('#leaderboard-body-admin .delete-player-button').forEach(button => {
                 button.replaceWith(button.cloneNode(true));
             });
             document.querySelectorAll('#leaderboard-body-admin .delete-player-button').forEach(button => {
                 button.addEventListener('click', async (e) => {
                     const id = e.target.dataset.id;
                     const playerName = e.target.closest('tr')?.querySelector('input[data-field="name"]')?.value || `ID: ${id}`;
                     console.log(`Attempting to delete player: ${playerName} (ID: ${id})`);
                     if (confirm(`Are you sure you want to delete player ${playerName}?`)) {
                         try {
                             await db.collection('leaderboard').doc(id).delete();
                              console.log(`Player ${id} deleted.`);
                             showSaveStatus('Player deleted successfully!', false);
                             loadLeaderboardAdmin();
                         } catch (error) {
                             console.error("Error deleting player:", error);
                             showSaveStatus(`Error deleting player: ${error.message}`, true);
                         }
                     } else { console.log("Deletion cancelled."); }
                 });
             });
         }

        async function loadBracketAdmin(bracketType = 'pro') {
            if (!bracketEditor) { console.error("loadBracketAdmin: bracketEditor element not found"); return; }
            bracketEditor.innerHTML = `Loading ${bracketType} bracket...`;
             console.log(`Loading bracket: ${bracketType}`);
            try {
                const docRef = db.collection('brackets').doc(bracketType);
                const docSnap = await docRef.get();

                if (docSnap.exists()) {
                    const bracketData = docSnap.data();
                     console.log(`Loaded bracket data for ${bracketType}:`, bracketData);
                    renderBracketEditor(bracketData, bracketType);
                } else {
                     console.log(`No bracket data found for ${bracketType}. Rendering empty editor.`);
                     renderBracketEditor({ rounds: [] }, bracketType, true); // Pass flag to attach listeners without clearing
                     bracketEditor.innerHTML = `<p>No bracket data found for ${bracketType}. You can add rounds and matches below.</p>`; // Set message after potentially attaching listeners
                }
            } catch (error) {
                console.error(`Error loading ${bracketType} bracket:`, error);
                 bracketEditor.innerHTML = `<p style="color:red;">Error loading ${bracketType} bracket.</p>`;
                 renderBracketEditor({ rounds: [] }, bracketType, true); // Attach listeners even on error
            }
        }

        // **FIXED renderBracketEditor** (ensures dataset.type is set)
        function renderBracketEditor(bracketData, bracketType, skipClear = false) {
             console.log(`Rendering bracket editor for ${bracketType}. SkipClear=${skipClear}`);
             if (!bracketEditor) { console.error("renderBracketEditor: bracketEditor element not found!"); return; } // Safety check

             // **Set the dataset type REGARDLESS of skipClear**
             bracketEditor.dataset.type = bracketType;
             console.log(`Set bracketEditor.dataset.type to: ${bracketEditor.dataset.type}`); // Verify it's set

             // Now handle clearing based on skipClear
             if (!skipClear) {
                 bracketEditor.innerHTML = ''; // Clear previous content if not skipping
             }

             if (!bracketData.rounds || bracketData.rounds.length === 0) {
                 // Only add "No rounds" message if we didn't just display an error / aren't skipping clear
                 if (!skipClear) {
                     bracketEditor.innerHTML += '<p>No rounds in this bracket yet.</p>';
                 }
                 console.log("No rounds found or rendering after error.");
                 attachBracketEditorListeners(); // Ensure listeners attached
                 return; // Stop rendering rounds if none exist
             }

            // Only render rounds if not skipping clear (i.e., successful load)
             if (!skipClear) {
                 bracketData.rounds.forEach((round, roundIndex) => {
                     console.log(`Rendering round ${roundIndex + 1}:`, round.name);
                     const roundDiv = document.createElement('div');
                     roundDiv.classList.add('bracket-round');
                     roundDiv.dataset.index = roundIndex;
                     roundDiv.innerHTML = `
                         <h4>Round ${roundIndex + 1}: <input type="text" value="${round.name || `Round ${roundIndex + 1}`}" class="round-name" placeholder="Round Name">
                         <button class="delete-round-button" data-index="${roundIndex}">Delete Round</button></h4>
                         <div class="matches-in-round">
                             ${!round.matches || round.matches.length === 0 ? '<p>No matches yet.</p>' : ''}
                         </div>
                         <button class="add-match-to-round-button" data-round-index="${roundIndex}">Add Match to this Round</button>
                     `;

                     const matchesContainer = roundDiv.querySelector('.matches-in-round');
                     if (round.matches && round.matches.length > 0) {
                         round.matches.forEach((match, matchIndex) => {
                             const matchDiv = renderBracketMatchEditor(match, roundIndex, matchIndex);
                             if (matchDiv && matchesContainer) { // Check elements exist
                                 matchesContainer.appendChild(matchDiv);
                             } else {
                                 console.error("Error: Couldn't append matchDiv, container or div is null", matchDiv, matchesContainer);
                             }
                         });
                     } else {
                          // Ensure the "No matches yet" paragraph exists if needed
                          if (matchesContainer && !matchesContainer.querySelector('p')) {
                              const p = document.createElement('p');
                              p.textContent = 'No matches yet.';
                              matchesContainer.appendChild(p);
                          }
                     }

                     bracketEditor.appendChild(roundDiv);
                 });
             }

             console.log("Attaching bracket editor listeners after rendering rounds.");
             attachBracketEditorListeners();
         }


        function attachBracketEditorListeners() {
             console.log("Attaching/Re-attaching listeners for bracket buttons...");
             if (!bracketEditor) return; // Safety check

             bracketEditor.removeEventListener('click', handleBracketButtonClick);
             bracketEditor.addEventListener('click', handleBracketButtonClick);
        }

        function handleBracketButtonClick(event) {
            const target = event.target;
             console.log("Bracket editor click detected on:", target);

            if (target.classList.contains('delete-round-button')) {
                console.log("Delete Round button click handled.");
                deleteBracketRound(target.dataset.index);
            } else if (target.classList.contains('add-match-to-round-button')) {
                console.log("Add Match button click handled.");
                addBracketMatch(target.dataset.roundIndex);
            } else if (target.classList.contains('delete-match-from-round-button')) {
                console.log("Delete Match button click handled.");
                // **Call the updated delete function**
                deleteBracketMatch(target.dataset.roundIndex, target.dataset.matchIndex);
            }
        }

        // **FIXED renderBracketMatchEditor** (handles empty match object)
        function renderBracketMatchEditor(match, roundIndex, matchIndex) {
             console.log(`Rendering match editor for R${roundIndex+1} M${matchIndex+1}`);
             const matchDiv = document.createElement('div');
             matchDiv.classList.add('bracket-match');
             matchDiv.dataset.roundIndex = roundIndex;
             matchDiv.dataset.matchIndex = matchIndex;
             // Use optional chaining (?.) and nullish coalescing (??) for safety
             matchDiv.innerHTML = `
                 <h5>Match ${matchIndex + 1}
                 <button class="delete-match-from-round-button" data-round-index="${roundIndex}" data-match-index="${matchIndex}">Delete Match</button>
                 </h5>
                 <label>Team 1 Name:</label> <input type="text" value="${match.team1?.name || ''}" class="bracket-team1-name">
                 <label>Team 1 Score:</label> <input type="number" value="${match.team1?.score ?? ''}" class="bracket-team1-score" placeholder="-">
                 <label>Team 2 Name:</label> <input type="text" value="${match.team2?.name || ''}" class="bracket-team2-name">
                 <label>Team 2 Score:</label> <input type="number" value="${match.team2?.score ?? ''}" class="bracket-team2-score" placeholder="-">
                 <label>Winner (Team Name or leave blank):</label> <input type="text" value="${match.winnerName || ''}" class="bracket-winner-name">
                 <label>Completed:</label> <input type="checkbox" ${match.completed ? 'checked' : ''} class="bracket-match-completed">
             `;
             return matchDiv;
         }

        // --- UI Interaction for Adding/Deleting Bracket Elements ---

         addRoundButton.addEventListener('click', () => {
             console.log("Add Round button clicked.");
             if (!bracketEditor) return; // Safety check
            const newRoundIndex = bracketEditor.querySelectorAll('.bracket-round').length;
             console.log(`Adding new round at index: ${newRoundIndex}`);
            const roundDiv = document.createElement('div');
            roundDiv.classList.add('bracket-round');
            roundDiv.dataset.index = newRoundIndex;
            roundDiv.innerHTML = `
                 <h4>Round ${newRoundIndex + 1}: <input type="text" value="New Round ${newRoundIndex + 1}" class="round-name" placeholder="Round Name">
                 <button class="delete-round-button" data-index="${newRoundIndex}">Delete Round</button></h4>
                 <div class="matches-in-round"><p>No matches yet.</p></div>
                 <button class="add-match-to-round-button" data-round-index="${newRoundIndex}">Add Match to this Round</button>
             `;

             const noRoundsMsg = bracketEditor.querySelector('p');
             if (noRoundsMsg && noRoundsMsg.textContent.includes('No rounds')) {
                 console.log("Removing 'No rounds' message.");
                 noRoundsMsg.remove();
             }
             bracketEditor.appendChild(roundDiv);
             // Event delegation handles listeners automatically
         });

        function deleteBracketRound(roundIndex) {
             console.log(`Attempting to delete round index: ${roundIndex}`);
             if (!bracketEditor) return; // Safety check
             if (confirm(`Are you sure you want to delete Round ${parseInt(roundIndex) + 1}?`)) {
                 const roundElement = bracketEditor.querySelector(`.bracket-round[data-index="${roundIndex}"]`);
                 if (roundElement) {
                     roundElement.remove();
                     console.log(`Removed round element index: ${roundIndex}`);
                     // Re-index subsequent rounds
                     let currentIdx = 0;
                     bracketEditor.querySelectorAll('.bracket-round').forEach((round) => {
                         const oldIndex = round.dataset.index;
                         round.dataset.index = currentIdx;
                         round.querySelector('h4').firstChild.textContent = `Round ${currentIdx + 1}: `;
                         const delBtn = round.querySelector('.delete-round-button');
                         if(delBtn) delBtn.dataset.index = currentIdx;
                         const addBtn = round.querySelector('.add-match-to-round-button');
                         if(addBtn) addBtn.dataset.roundIndex = currentIdx;
                         round.querySelectorAll('.bracket-match').forEach(match => {
                            match.dataset.roundIndex = currentIdx;
                             const delMatchBtn = match.querySelector('.delete-match-from-round-button');
                             if(delMatchBtn) delMatchBtn.dataset.roundIndex = currentIdx;
                         });
                         console.log(`Re-indexed round from ${oldIndex} to ${currentIdx}`);
                         currentIdx++;
                     });
                 } else {
                     console.warn(`Could not find round element to delete index: ${roundIndex}`);
                 }
             } else {
                 console.log("Deletion cancelled.");
             }
         }

        function addBracketMatch(roundIndex) {
            console.log('--- addBracketMatch called --- roundIndex:', roundIndex);
             if (!bracketEditor) return; // Safety check

            const roundElement = bracketEditor.querySelector(`.bracket-round[data-index="${roundIndex}"]`);
            console.log('Found roundElement:', roundElement);

            if (!roundElement) {
                console.error('addBracketMatch ERROR: Could not find round element for index:', roundIndex);
                alert('Error: Could not find the round container. Please refresh and try again.');
                return;
            }

            const matchesContainer = roundElement.querySelector('.matches-in-round');
            console.log('Found matchesContainer:', matchesContainer);

            if (!matchesContainer) {
                console.error('addBracketMatch ERROR: Could not find matchesContainer within round element:', roundElement);
                 alert('Error: Could not find the match container within the round. Please refresh and try again.');
                return;
            }

            const newMatchIndex = matchesContainer.querySelectorAll('.bracket-match').length;
            console.log('Calculated newMatchIndex:', newMatchIndex);

            try {
                const matchDiv = renderBracketMatchEditor({}, roundIndex, newMatchIndex);
                console.log('Rendered matchDiv:', matchDiv);

                const noMatchesMsg = matchesContainer.querySelector('p');
                if (noMatchesMsg && noMatchesMsg.textContent.includes('No matches')) {
                    console.log('Removing "No matches" message');
                    noMatchesMsg.remove();
                }

                console.log('Appending matchDiv to matchesContainer');
                matchesContainer.appendChild(matchDiv);
                console.log('--- addBracketMatch finished successfully ---');

            } catch (error) {
                 console.error("Error during addBracketMatch execution (render or append):", error);
                 alert('An error occurred while adding the match editor.');
            }
        }

        // **UPDATED deleteBracketMatch** (Includes Firestore update)
        async function deleteBracketMatch(roundIndex, matchIndex) {
            const R_IDX = parseInt(roundIndex);
            const M_IDX = parseInt(matchIndex);
            console.log(`Attempting to delete match index ${M_IDX} from round index ${R_IDX}`);
            if (!bracketEditor) { console.error("Delete Error: bracketEditor not found"); return; }

            const bracketType = bracketEditor.dataset.type;
            if (!bracketType) {
                 console.error("Delete Error: Cannot determine bracket type.");
                 showSaveStatus('Error: Cannot determine bracket type to delete match from.', true);
                 return;
            }

            if (confirm(`Are you sure you want to delete Match ${M_IDX + 1} from Round ${R_IDX + 1}? This will remove it permanently.`)) {
                const docRef = db.collection('brackets').doc(bracketType);
                try {
                    // Use a transaction to read, modify, and write
                    await db.runTransaction(async (transaction) => {
                        const docSnap = await transaction.get(docRef);
                        if (!docSnap.exists()) {
                            throw new Error("Bracket document does not exist!");
                        }

                        // Get a mutable copy of the rounds data
                        const data = docSnap.data();
                        // Deep copy to avoid modifying snapshot data directly
                        const currentRounds = data.rounds ? JSON.parse(JSON.stringify(data.rounds)) : [];

                        // Validate indices
                        if (R_IDX < 0 || R_IDX >= currentRounds.length || !currentRounds[R_IDX].matches) {
                             throw new Error(`Invalid round index (${R_IDX}) or round has no matches array.`);
                        }
                         if (M_IDX < 0 || M_IDX >= currentRounds[R_IDX].matches.length) {
                             throw new Error(`Invalid match index (${M_IDX}) for round ${R_IDX}.`);
                        }

                        // Remove the match from the array copy
                        console.log(`Removing match at R_IDX ${R_IDX}, M_IDX ${M_IDX}`);
                        currentRounds[R_IDX].matches.splice(M_IDX, 1);

                        // Update the document in the transaction with the modified array
                         console.log("Updating Firestore with modified rounds:", currentRounds);
                        transaction.update(docRef, { rounds: currentRounds });
                    });

                    // --- Firestore update successful, now update the UI ---
                    console.log("Firestore transaction successful. Match removed from data.");
                    showSaveStatus('Match deleted successfully from bracket!', false);

                    const matchElement = bracketEditor.querySelector(`.bracket-match[data-round-index="${R_IDX}"][data-match-index="${M_IDX}"]`);
                    if (matchElement) {
                        const container = matchElement.parentElement;
                        matchElement.remove();
                        console.log(`Removed match element UI R${R_IDX} M${M_IDX}`);
                        // Re-index subsequent matches *in the UI*
                        let currentMIdx = 0;
                        container.querySelectorAll('.bracket-match').forEach((matchUI) => {
                            matchUI.dataset.matchIndex = currentMIdx;
                            matchUI.querySelector('h5').firstChild.textContent = `Match ${currentMIdx + 1} `;
                            const delMatchBtn = matchUI.querySelector('.delete-match-from-round-button');
                            if(delMatchBtn) delMatchBtn.dataset.matchIndex = currentMIdx;
                            currentMIdx++;
                        });
                        if (container.querySelectorAll('.bracket-match').length === 0 && !container.querySelector('p')) {
                            const p = document.createElement('p');
                            p.textContent = 'No matches yet.';
                            container.appendChild(p);
                            console.log("Added back 'No matches yet.' message to UI.");
                        }
                    } else {
                       console.warn(`Could not find match element UI to remove R${R_IDX} M${M_IDX} after successful delete. UI might be out of sync.`);
                       // Optionally reload the entire bracket editor UI if this happens frequently
                       // loadBracketAdmin(bracketType);
                    }
                     // --- End UI Update ---

                } catch (error) {
                    console.error("Error deleting bracket match from Firestore:", error);
                    showSaveStatus(`Error deleting match: ${error.message}`, true);
                }
            } else {
                console.log("Deletion cancelled.");
            }
        }


        // --- Data Saving ---

         function showSaveStatus(message, isError = false) {
            console.log(`Save Status: ${message} (Error: ${isError})`);
            if (!saveStatus) return; // Safety check
            saveStatus.textContent = message;
            saveStatus.style.color = isError ? 'red' : 'lightgreen';
             if (window.saveStatusTimeout) clearTimeout(window.saveStatusTimeout);
             window.saveStatusTimeout = setTimeout(() => { saveStatus.textContent = ''; }, 5000);
         }

         // Save Individual New Match
        addMatchButton.addEventListener('click', () => {
             console.log("Toggle Add New Match form visibility.");
              if (addMatchForm) addMatchForm.classList.toggle('hidden');
        });
        saveNewMatchButton.addEventListener('click', async () => {
             console.log("Attempting to save NEW match...");
             const dateValue = document.getElementById('new-match-date').value;
             let matchDateTimestamp = null;
             if (dateValue) {
                 try {
                     matchDateTimestamp = firebase.firestore.Timestamp.fromDate(new Date(dateValue));
                 } catch (e) {
                     console.error("Invalid date entered for new match:", e);
                     showSaveStatus('Error: Invalid Date format entered.', true);
                     return;
                 }
             }

             const newMatchData = {
                 date: matchDateTimestamp,
                 type: document.getElementById('new-match-type').value.trim(),
                 team1: {
                     name: document.getElementById('new-match-team1-name').value.trim(),
                     logo: document.getElementById('new-match-team1-logo').value.trim().toUpperCase()
                 },
                 team2: {
                     name: document.getElementById('new-match-team2-name').value.trim(),
                     logo: document.getElementById('new-match-team2-logo').value.trim().toUpperCase()
                 },
                 venue: document.getElementById('new-match-venue').value.trim(),
                 streamLink: document.getElementById('new-match-stream').value.trim()
             };

             if (!newMatchData.date || !newMatchData.team1.name || !newMatchData.team2.name || !newMatchData.type) {
                  console.warn("Validation failed for new match:", newMatchData);
                 showSaveStatus('Error: Date, Type, Team 1 Name, and Team 2 Name are required.', true);
                 return;
             }
             console.log("New match data validated:", newMatchData);

             try {
                 const docRef = await db.collection('matches').add(newMatchData);
                 console.log("New match added successfully with ID:", docRef.id);
                 showSaveStatus('New match added successfully!', false);
                 addMatchForm.classList.add('hidden');
                addMatchForm.querySelectorAll('input').forEach(input => input.value = (input.id === 'new-match-stream' ? 'https://www.twitch.tv/poxelcompetitive/' : ''));
                 loadMatchesAdmin();
             } catch (error) {
                 console.error("Error adding new match to Firestore:", error);
                 showSaveStatus(`Error adding match: ${error.message}`, true);
             }
        });

         // Save ALL Match Changes (Updates Existing)
        saveMatchesChangesButton.addEventListener('click', async () => {
             console.log("Attempting to save ALL match changes...");
             const updates = [];
             let overallError = false;

             document.querySelectorAll('#matches-list .match-editor').forEach(editor => {
                 const id = editor.dataset.id;
                 if (!id) return;

                 const matchData = { team1: {}, team2: {} };
                 let hasDateError = false;
                 let dateValue = editor.querySelector('input[data-field="date"]')?.value;

                 if (dateValue) {
                     try {
                         matchData.date = firebase.firestore.Timestamp.fromDate(new Date(dateValue));
                     } catch (e) {
                         console.error(`Invalid date for match ${id}: ${dateValue}`, e);
                         showSaveStatus(`Error: Invalid date format for Match ID ${id}.`, true);
                         hasDateError = true;
                         overallError = true;
                     }
                 } else {
                      console.warn(`Date missing for match ${id}.`);
                      showSaveStatus(`Warning: Date missing for Match ID ${id}. It might not display correctly.`, true);
                      matchData.date = null;
                      hasDateError = true;
                       overallError = true;
                 }

                  if (!hasDateError) {
                     editor.querySelectorAll('input:not([data-field="date"])').forEach(input => {
                         const fieldPath = input.dataset.field;
                         let value = input.value.trim();
                         if (fieldPath?.includes('.')) {
                             const parts = fieldPath.split('.');
                             if (parts.length === 2) {
                                 if (!matchData[parts[0]]) matchData[parts[0]] = {};
                                 matchData[parts[0]][parts[1]] = value;
                             }
                         } else if (fieldPath) {
                             matchData[fieldPath] = value;
                         }
                     });
                      console.log(`Queueing update for match ${id}:`, matchData);
                      updates.push({ id: id, data: matchData });
                  }
             });

             if (updates.length === 0 && !overallError) {
                 console.log("No valid match changes detected to save.");
                 showSaveStatus('No changes detected in existing matches.', false);
                 return;
             }
              if (updates.length === 0 && overallError) {
                 console.log("No valid match changes to save due to errors.");
                 return;
             }

             console.log(`Preparing batch update for ${updates.length} matches.`);
             const batch = db.batch();
             updates.forEach(update => {
                 const docRef = db.collection('matches').doc(update.id);
                 batch.update(docRef, update.data);
             });

             try {
                 await batch.commit();
                 console.log("Batch update successful.");
                 showSaveStatus(`${updates.length} match(es) updated successfully!`, false);
                 loadMatchesAdmin();
             } catch (error) {
                 console.error("Error committing batch update for matches:", error);
                 showSaveStatus(`Error saving match changes: ${error.message}`, true);
             }
        });

         // Save Individual New Player
        addPlayerButton.addEventListener('click', () => {
             console.log("Toggle Add New Player form.");
              if (addPlayerForm) addPlayerForm.classList.toggle('hidden');
        });
        saveNewPlayerButton.addEventListener('click', async () => {
             console.log("Attempting to save new player...");
            const newPlayerData = {
                 name: document.getElementById('new-player-name').value.trim(),
                 avatar: document.getElementById('new-player-avatar').value.trim().toUpperCase(),
                 matches: parseInt(document.getElementById('new-player-matches').value) || 0,
                 wins: parseInt(document.getElementById('new-player-wins').value) || 0,
                 losses: parseInt(document.getElementById('new-player-losses').value) || 0,
                 points: parseInt(document.getElementById('new-player-points').value) || 0
            };

            if (!newPlayerData.name) {
                 console.warn("New player validation failed: Name required.");
                showSaveStatus('Error: Player Name is required.', true);
                return;
            }
             console.log("New player data validated:", newPlayerData);

             try {
                 const docRef = await db.collection('leaderboard').add(newPlayerData);
                 console.log("New player added successfully with ID:", docRef.id);
                 showSaveStatus('New player added successfully!', false);
                 addPlayerForm.classList.add('hidden');
                 addPlayerForm.querySelectorAll('input').forEach(input => input.value = (input.type === 'number' ? '0' : ''));
                 loadLeaderboardAdmin();
             } catch (error) {
                 console.error("Error adding new player to Firestore:", error);
                 showSaveStatus(`Error adding player: ${error.message}`, true);
             }
        });

         // Save ALL Leaderboard Changes
        saveLeaderboardChangesButton.addEventListener('click', async () => {
            console.log("Attempting to save all leaderboard changes...");
             const updates = [];
             document.querySelectorAll('#leaderboard-body-admin tr').forEach(row => {
                 const id = row.dataset.id;
                 if (!id) return;

                 const playerData = {};
                 row.querySelectorAll('input').forEach(input => {
                     const field = input.dataset.field;
                     let value = input.value.trim();
                     if (input.type === 'number') {
                         value = parseInt(value) || 0; // Ensure it's a number
                     } else if (field === 'avatar') {
                         value = value.toUpperCase();
                     }
                     playerData[field] = value;
                 });
                 console.log(`Queueing update for player ${id}:`, playerData);
                 updates.push({ id: id, data: playerData });
             });

             if (updates.length === 0) {
                 console.log("No leaderboard changes detected to save.");
                 showSaveStatus('No changes detected in leaderboard.', false);
                 return;
             }

             console.log(`Preparing batch update for ${updates.length} players.`);
             const batch = db.batch();
             updates.forEach(update => {
                 const docRef = db.collection('leaderboard').doc(update.id);
                 batch.update(docRef, update.data); // Use update
             });

             try {
                 await batch.commit();
                  console.log("Leaderboard batch update successful.");
                 showSaveStatus(`${updates.length} player(s) updated successfully!`, false);
                 loadLeaderboardAdmin();
             } catch (error) {
                 console.error("Error updating leaderboard:", error);
                 showSaveStatus(`Error saving leaderboard changes: ${error.message}`, true);
             }
        });


        // Save Bracket Changes
        bracketSelect.addEventListener('change', (e) => {
            console.log(`Bracket selection changed to: ${e.target.value}`);
            loadBracketAdmin(e.target.value)
        });
        saveBracketChangesButton.addEventListener('click', async () => {
             const bracketType = bracketEditor?.dataset.type; // Use optional chaining
            console.log(`Attempting to save bracket changes for: ${bracketType}`);
            if (!bracketType) {
                 console.error("Save Bracket Error: Cannot determine bracket type from dataset.");
                showSaveStatus('Error: Cannot determine which bracket to save. Select bracket type or ensure editor loaded.', true);
                return;
            }

            const bracketData = { rounds: [] };
             let errorInData = false;

            bracketEditor.querySelectorAll('.bracket-round').forEach((roundDiv, roundIndex) => {
                 console.log(`Processing round ${roundIndex + 1} for saving...`);
                const round = {
                    name: roundDiv.querySelector('.round-name').value.trim() || `Round ${roundIndex + 1}`,
                    matches: []
                };

                roundDiv.querySelectorAll('.bracket-match').forEach((matchDiv, matchIndex) => {
                    console.log(`Processing match ${matchIndex + 1} in round ${roundIndex + 1}...`);
                    const t1ScoreInput = matchDiv.querySelector('.bracket-team1-score').value;
                    const t2ScoreInput = matchDiv.querySelector('.bracket-team2-score').value;
                    const winnerNameInput = matchDiv.querySelector('.bracket-winner-name').value.trim();
                    const t1Name = matchDiv.querySelector('.bracket-team1-name').value.trim();
                     const t2Name = matchDiv.querySelector('.bracket-team2-name').value.trim();

                    const t1Score = t1ScoreInput !== '' ? parseInt(t1ScoreInput) : null;
                    const t2Score = t2ScoreInput !== '' ? parseInt(t2ScoreInput) : null;

                    const match = {
                        team1: { name: t1Name, score: t1Score },
                        team2: { name: t2Name, score: t2Score },
                        winnerName: winnerNameInput || null,
                        completed: matchDiv.querySelector('.bracket-match-completed').checked
                    };

                     if ((t1ScoreInput !== '' && isNaN(t1Score)) || (t2ScoreInput !== '' && isNaN(t2Score))) {
                         console.error(`Invalid score input in R${roundIndex+1} M${matchIndex+1}. T1: ${t1ScoreInput}, T2: ${t2ScoreInput}`);
                         showSaveStatus(`Error: Invalid score in Round ${roundIndex+1}, Match ${matchIndex+1}. Please enter numbers only.`, true);
                         errorInData = true;
                     }

                     if(match.winnerName && match.completed) {
                         if (match.winnerName.toLowerCase() === match.team1.name?.toLowerCase()) {
                             match.winner = match.team1.name;
                         } else if (match.winnerName.toLowerCase() === match.team2.name?.toLowerCase()) {
                            match.winner = match.team2.name;
                         } else {
                              console.warn(`Winner name "${match.winnerName}" in R${roundIndex+1} M${matchIndex+1} doesn't match team names.`);
                              match.winner = null;
                         }
                     } else {
                         match.winner = null;
                     }

                     console.log(`Match data compiled for R${roundIndex+1} M${matchIndex+1}:`, match);
                    round.matches.push(match);
                });
                bracketData.rounds.push(round);
            });

             if (errorInData) {
                 console.error("Bracket saving aborted due to data errors.");
                 return;
             }

             console.log(`Compiled bracket data for ${bracketType}:`, bracketData);
             try {
                 const docRef = db.collection('brackets').doc(bracketType);
                 await docRef.set(bracketData);
                  console.log("Bracket data saved successfully to Firestore.");
                 showSaveStatus(`${bracketType} bracket saved successfully!`, false);
             } catch (error) {
                 console.error(`Error saving ${bracketType} bracket to Firestore:`, error);
                 showSaveStatus(`Error saving ${bracketType} bracket: ${error.message}`, true);
             }
        });

        // --- Initial Load Call ---
        console.log("Admin script initialized. Waiting for authentication state...");

        document.addEventListener('DOMContentLoaded', () => {
             console.log("DOM Content Loaded.");
             // Attach listeners for non-dynamic elements here if needed
        });

        // --- END OF SCRIPT --- //
    </script>

</body>
</html>
