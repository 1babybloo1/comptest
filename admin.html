<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poxel Competitive - Admin Panel</title>
    <style>
        :root {
            --dark: #121212;
            --dark-accent: #1e1e1e;
            --orange: #ff5722;
            --text: #f5f5f5;
            --text-secondary: #aaaaaa;
        }
        body { background-color: var(--dark); color: var(--text); font-family: sans-serif; padding: 20px; }
        #login-container, #admin-panel { background-color: var(--dark-accent); padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        h1, h2 { color: var(--orange); }
        button { background-color: var(--orange); color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { opacity: 0.9; }
        #logout-button { background-color: #555; }
        .admin-section { margin-top: 20px; border-top: 1px solid #444; padding-top: 20px; }
        label { display: block; margin-bottom: 5px; color: var(--text-secondary); }
        input[type="text"], input[type="datetime-local"], input[type="number"], textarea, select { /* Added select styling */
            width: 95%; padding: 8px; margin-bottom: 10px; background-color: #333; border: 1px solid #555; color: var(--text); border-radius: 4px;
        }
        .hidden { display: none; }
        .fade-in { animation: fadeIn 0.5s ease forwards; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        th, td { border: 1px solid #444; padding: 8px; text-align: left; }
        th { background-color: rgba(255, 87, 34, 0.1); color: var(--orange); }
        .match-editor, .player-editor, .bracket-editor { margin-bottom: 15px; padding: 10px; border: 1px dashed #555; border-radius: 5px; background-color: rgba(0,0,0,0.1); } /* Added background */
        .bracket-round { margin-bottom: 10px; padding: 15px; border-left: 2px solid var(--orange); background-color: rgba(0,0,0,0.1); }
        .bracket-match { margin-bottom: 10px; padding: 10px; border: 1px solid #444; border-radius: 4px; background-color: var(--dark-accent); }
        .matches-in-round { padding-top: 10px; }
         .loading-indicator {
             font-style: italic;
             color: var(--text-secondary);
             padding: 10px;
             text-align: center;
             border: 1px dashed var(--text-secondary);
             margin-top: 10px;
         }
         /* New styles for created brackets list */
         #created-brackets-list { margin-top: 15px; }
         .bracket-summary-item {
             background-color: var(--dark);
             padding: 15px;
             border: 1px solid #444;
             border-radius: 5px;
             margin-bottom: 10px;
             display: flex;
             justify-content: space-between;
             align-items: center;
         }
         .bracket-summary-item h4 { margin: 0; color: var(--text); }
         .bracket-summary-item span { color: var(--text-secondary); font-size: 0.9em; }
         .delete-button { /* General delete button style */
            background-color: #d32f2f; /* Red */
         }
         .delete-button:hover { background-color: #b71c1c; }

         /* Style for the specific editor form */
         #bracket-editor-form {
             border: 2px solid var(--orange);
             margin-top: 20px;
         }
    </style>
</head>
<body>

    <h1>Poxel Competitive - Admin</h1>

    <!-- Login Section -->
    <div id="login-container">
        <h2>Admin Login</h2>
        <p>Please log in with your authorized Google account.</p>
        <button id="login-button">Login with Google</button>
        <p id="login-error" style="color: red;"></p>
    </div>

    <!-- Admin Panel (Initially Hidden) -->
    <div id="admin-panel" class="hidden">
        <div style="display: flex; justify-content: space-between; align-items: center;">
            <h2>Management Dashboard</h2>
            <div>
                <span id="user-info" style="margin-right: 15px;"></span>
                <button id="logout-button">Logout</button>
            </div>
        </div>
         <p style="color: lightgreen;" id="save-status"></p> <!-- General Status Message -->

        <!-- Upcoming Matches Management (Keep as is) -->
        <div class="admin-section">
            <h3>Upcoming Matches Management</h3>
            <div id="matches-list">
                <div class="loading-indicator">Loading matches...</div>
            </div>
            <button id="add-match-button">Add New Match</button>
            <div id="add-match-form" class="match-editor hidden">
                 <h4>New Match Details</h4>
                 <label for="new-match-date">Date & Time:</label>
                 <input type="datetime-local" id="new-match-date">
                 <label for="new-match-type">Type (e.g., Quarterfinals):</label>
                 <input type="text" id="new-match-type">
                 <label for="new-match-team1-name">Team 1 Name:</label>
                 <input type="text" id="new-match-team1-name">
                 <label for="new-match-team1-logo">Team 1 Logo (Initials):</label>
                 <input type="text" id="new-match-team1-logo" maxlength="2">
                 <label for="new-match-team2-name">Team 2 Name:</label>
                 <input type="text" id="new-match-team2-name">
                 <label for="new-match-team2-logo">Team 2 Logo (Initials):</label>
                 <input type="text" id="new-match-team2-logo" maxlength="2">
                 <label for="new-match-venue">Venue:</label>
                 <input type="text" id="new-match-venue">
                 <label for="new-match-stream">Stream Link:</label>
                 <input type="text" id="new-match-stream" value="https://www.twitch.tv/poxelcompetitive/">
                 <button id="save-new-match">Save New Match</button>
                 <button type="button" onclick="document.getElementById('add-match-form').classList.add('hidden')">Cancel</button>
            </div>
            <button id="save-matches-changes">Save All Match Changes</button>
        </div>

        <!-- Leaderboard Management (Keep as is) -->
        <div class="admin-section">
            <h3>Leaderboard Management</h3>
            <div id="leaderboard-list">
                 <table>
                     <thead>
                         <tr>
                             <th>Rank</th>
                             <th>Player Name</th>
                             <th>Avatar</th>
                             <th>Matches</th>
                             <th>Wins</th>
                             <th>Losses</th>
                             <th>Points</th>
                             <th>Actions</th>
                         </tr>
                     </thead>
                     <tbody id="leaderboard-body-admin">
                         <!-- Leaderboard entries loaded here -->
                     </tbody>
                 </table>
                 <div class="loading-indicator hidden" id="leaderboard-loading">Loading leaderboard...</div>
            </div>
             <button id="add-player-button">Add New Player</button>
             <div id="add-player-form" class="player-editor hidden">
                 <h4>New Player Details</h4>
                 <label>Name:</label><input type="text" id="new-player-name">
                 <label>Avatar (Initials):</label><input type="text" id="new-player-avatar" maxlength="2">
                 <label>Matches:</label><input type="number" id="new-player-matches" value="0" min="0">
                 <label>Wins:</label><input type="number" id="new-player-wins" value="0" min="0">
                 <label>Losses:</label><input type="number" id="new-player-losses" value="0" min="0">
                 <label>Points:</label><input type="number" id="new-player-points" value="0">
                 <button id="save-new-player">Save New Player</button>
                 <button type="button" onclick="document.getElementById('add-player-form').classList.add('hidden')">Cancel</button>
            </div>
            <button id="save-leaderboard-changes">Save Leaderboard Changes</button>
        </div>

        <!-- Tournament Bracket Management (REWORKED SECTION) -->
        <div class="admin-section">
            <h3>Tournament Bracket Management</h3>

            <!-- Section to display existing brackets -->
            <h4>Created Brackets</h4>
            <div id="created-brackets-list">
                <div class="loading-indicator" id="created-brackets-loading">Loading existing brackets...</div>
                <!-- Summary of existing brackets will be loaded here -->
                 <!-- Example Item (will be generated by JS):
                 <div class="bracket-summary-item">
                    <div>
                        <h4>Pro Tourney</h4>
                        <span>3 Rounds, 7 Matches</span>
                    </div>
                    <button class="delete-button delete-bracket-button" data-bracket-type="pro">Delete Pro Bracket</button>
                 </div>
                 -->
            </div>
            <p id="no-brackets-message" class="hidden" style="color: var(--text-secondary); margin-top: 10px;">No brackets found in the database.</p>

            <hr style="border-color: #444; margin: 20px 0;">

            <!-- Section to select and edit/create a bracket -->
            <h4>Edit/Create Bracket</h4>
            <label for="bracket-select">Select Bracket to Edit/Create:</label>
            <select id="bracket-select">
                <option value="pro">Pro Tourney</option>
                <option value="novice">Novice Tourney</option>
            </select>
            <button id="edit-create-bracket-button">Edit/Create Selected Bracket</button>

            <!-- The Actual Editor Form (Initially Hidden) -->
            <div id="bracket-editor-form" class="bracket-editor hidden">
                <h4 id="bracket-editor-heading">Editing Bracket...</h4>
                 <div id="bracket-editor-loading" class="loading-indicator hidden">Loading bracket data...</div>
                 <div id="bracket-editor-content">
                     <!-- Rounds and matches UI will be dynamically added here -->
                 </div>
                 <div style="margin-top: 15px; border-top: 1px solid #444; padding-top: 15px;">
                     <button id="add-round-to-editor-button">Add Round</button>
                     <button id="save-bracket-editor-changes-button">Save Bracket Changes</button>
                     <button id="cancel-bracket-editor-button" type="button" style="background-color: #555;">Cancel Edit</button>
                 </div>
            </div>
        </div>

    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

    <script>
        // --- START OF SCRIPT --- //

        // IMPORTANT: Firebase Config
        const firebaseConfig = {
            apiKey: "AIzaSyDWFPys8dbSgis98tbm5PVqMuHqnCpPIxI", // Replace if needed
             authDomain: "poxelcomp.firebaseapp.com", // Replace if needed
             projectId: "poxelcomp", // Replace if needed
             storageBucket: "poxelcomp.firebasestorage.app", // Replace if needed
             messagingSenderId: "620490990104", // Replace if needed
             appId: "1:620490990104:web:709023eb464c7d886b996d", // Replace if needed
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
        const googleProvider = new firebase.auth.GoogleAuthProvider();

        // --- DOM Elements ---
        const loginContainer = document.getElementById('login-container');
        const adminPanel = document.getElementById('admin-panel');
        const loginButton = document.getElementById('login-button');
        const logoutButton = document.getElementById('logout-button');
        const userInfo = document.getElementById('user-info');
        const loginError = document.getElementById('login-error');
        const saveStatus = document.getElementById('save-status'); // General status

        // Matches Elements
        const matchesList = document.getElementById('matches-list');
        const addMatchButton = document.getElementById('add-match-button');
        const addMatchForm = document.getElementById('add-match-form');
        const saveNewMatchButton = document.getElementById('save-new-match');
        const saveMatchesChangesButton = document.getElementById('save-matches-changes');

        // Leaderboard Elements
        const leaderboardList = document.getElementById('leaderboard-list');
        const leaderboardBodyAdmin = document.getElementById('leaderboard-body-admin');
        const leaderboardLoading = document.getElementById('leaderboard-loading');
        const addPlayerButton = document.getElementById('add-player-button');
        const addPlayerForm = document.getElementById('add-player-form');
        const saveNewPlayerButton = document.getElementById('save-new-player');
        const saveLeaderboardChangesButton = document.getElementById('save-leaderboard-changes');

        // Bracket Elements (Reworked)
        const createdBracketsList = document.getElementById('created-brackets-list');
        const createdBracketsLoading = document.getElementById('created-brackets-loading');
        const noBracketsMessage = document.getElementById('no-brackets-message');
        const bracketSelect = document.getElementById('bracket-select');
        const editCreateBracketButton = document.getElementById('edit-create-bracket-button');
        const bracketEditorForm = document.getElementById('bracket-editor-form');
        const bracketEditorHeading = document.getElementById('bracket-editor-heading');
        const bracketEditorLoading = document.getElementById('bracket-editor-loading');
        const bracketEditorContent = document.getElementById('bracket-editor-content'); // Where rounds/matches go
        const addRoundToEditorButton = document.getElementById('add-round-to-editor-button');
        const saveBracketEditorChangesButton = document.getElementById('save-bracket-editor-changes-button');
        const cancelBracketEditorButton = document.getElementById('cancel-bracket-editor-button');

        // --- Utility Functions ---
        function showSaveStatus(message, isError = false, duration = 5000) {
            console.log(`Save Status: ${message} (Error: ${isError})`);
            if (!saveStatus) return;
            saveStatus.textContent = message;
            saveStatus.style.color = isError ? 'red' : 'lightgreen';
            if (window.saveStatusTimeout) clearTimeout(window.saveStatusTimeout);
            if (duration > 0) {
                window.saveStatusTimeout = setTimeout(() => { saveStatus.textContent = ''; }, duration);
            }
        }

        function showLoading(element, show = true, message = "Loading...") {
             if (element) {
                element.textContent = message;
                element.classList.toggle('hidden', !show);
             }
        }

        // --- Authentication ---
        auth.onAuthStateChanged(user => {
            if (user) {
                console.log("User signed in:", user.email);
                loginContainer.classList.add('hidden');
                adminPanel.classList.remove('hidden');
                adminPanel.classList.add('fade-in');
                userInfo.textContent = `Logged in as: ${user.displayName || user.email}`;
                loadAdminData(); // Load data once logged in
            } else {
                console.log("User signed out.");
                adminPanel.classList.add('hidden');
                adminPanel.classList.remove('fade-in');
                loginContainer.classList.remove('hidden');
                userInfo.textContent = '';
                clearAdminUI(); // Clear data when logged out
            }
        });

        loginButton.addEventListener('click', () => {
            loginError.textContent = '';
            auth.signInWithPopup(googleProvider)
                .catch((error) => {
                    console.error("Login failed:", error);
                    loginError.textContent = `Login failed: ${error.message}`;
                });
        });

        logoutButton.addEventListener('click', () => { auth.signOut(); });

        function clearAdminUI() {
            console.log("Clearing Admin UI...");
            if (matchesList) matchesList.innerHTML = '';
            if (leaderboardBodyAdmin) leaderboardBodyAdmin.innerHTML = '';
            if (createdBracketsList) createdBracketsList.innerHTML = ''; // Clear created brackets list
            if (bracketEditorContent) bracketEditorContent.innerHTML = ''; // Clear editor content
            if (bracketEditorForm) bracketEditorForm.classList.add('hidden'); // Hide editor form
            if (saveStatus) saveStatus.textContent = '';
            if (addMatchForm) addMatchForm.classList.add('hidden');
            if (addPlayerForm) addPlayerForm.classList.add('hidden');
            if (noBracketsMessage) noBracketsMessage.classList.add('hidden');
        }

        // --- Data Loading ---
        function loadAdminData() {
            console.log("Loading all admin data...");
            showSaveStatus("Loading data...", false, 0); // Indicate loading
            Promise.all([
                loadMatchesAdmin(),
                loadLeaderboardAdmin(),
                loadCreatedBracketsSummary() // Load the summary list
            ]).then(() => {
                 showSaveStatus("Data loaded.", false);
                 console.log("All admin data loaded.");
            }).catch(error => {
                 console.error("Error loading admin data:", error);
                 showSaveStatus("Error loading data. Check console.", true);
            });
        }

        // --- Matches Management (Largely Unchanged) ---
        async function loadMatchesAdmin() {
            if (!matchesList) { console.error("loadMatchesAdmin: matchesList element not found"); return; }
            matchesList.innerHTML = '<div class="loading-indicator">Loading matches...</div>';
            try {
                const snapshot = await db.collection('matches').orderBy('date', 'desc').get();
                matchesList.innerHTML = ''; // Clear loading
                if (snapshot.empty) {
                    matchesList.innerHTML = '<p>No matches found.</p>';
                    return;
                }
                snapshot.forEach(doc => {
                    const match = { id: doc.id, ...doc.data() };
                    const dateForInput = match.date?.toDate ? new Date(match.date.toDate().getTime() - match.date.toDate().getTimezoneOffset() * 60000).toISOString().slice(0, 16) : '';
                    const matchDiv = document.createElement('div');
                    matchDiv.classList.add('match-editor');
                    matchDiv.dataset.id = match.id;
                    matchDiv.innerHTML = `
                         <h4>Match ID: ${match.id}</h4>
                         <label>Date:</label><input type="datetime-local" value="${dateForInput}" data-field="date">
                         <label>Type:</label><input type="text" value="${match.type || ''}" data-field="type">
                         <label>Team 1:</label><input type="text" value="${match.team1?.name || ''}" data-field="team1.name">
                         <label>Team 1 Logo:</label><input type="text" value="${match.team1?.logo || ''}" data-field="team1.logo" maxlength="2">
                         <label>Team 2:</label><input type="text" value="${match.team2?.name || ''}" data-field="team2.name">
                         <label>Team 2 Logo:</label><input type="text" value="${match.team2?.logo || ''}" data-field="team2.logo" maxlength="2">
                         <label>Venue:</label><input type="text" value="${match.venue || ''}" data-field="venue">
                         <label>Stream:</label><input type="text" value="${match.streamLink || ''}" data-field="streamLink">
                         <button class="delete-button delete-match-button" data-id="${match.id}">Delete Match</button> <!-- Added delete-button class -->
                     `;
                    matchesList.appendChild(matchDiv);
                });
                attachMatchActionListeners(); // Renamed for clarity

            } catch (error) {
                console.error("Error loading matches:", error);
                matchesList.innerHTML = '<p style="color:red;">Error loading matches.</p>';
            }
        }

        function attachMatchActionListeners() {
             // Use event delegation on the container
             matchesList.removeEventListener('click', handleMatchActions); // Prevent multiple listeners
             matchesList.addEventListener('click', async (e) => {
                 if (e.target.classList.contains('delete-match-button')) {
                     const id = e.target.dataset.id;
                     console.log(`Attempting to delete match ID: ${id}`);
                     if (confirm(`Are you sure you want to delete match ${id}?`)) {
                         showSaveStatus("Deleting match...", false, 0);
                         try {
                             await db.collection('matches').doc(id).delete();
                             console.log(`Match ${id} deleted.`);
                             showSaveStatus('Match deleted successfully!', false);
                             e.target.closest('.match-editor')?.remove(); // Remove from UI immediately
                             // Optional: Reload if needed, but removing directly is faster UI feedback
                             // loadMatchesAdmin();
                             if(matchesList.children.length === 0) {
                                 matchesList.innerHTML = '<p>No matches found.</p>';
                             }
                         } catch (error) {
                             console.error("Error deleting match:", error);
                             showSaveStatus(`Error deleting match: ${error.message}`, true);
                         }
                     } else { console.log("Deletion cancelled."); }
                 }
             });
        }
        // Add New Match Button
        addMatchButton.addEventListener('click', () => addMatchForm.classList.toggle('hidden'));
        // Save New Match Button
        saveNewMatchButton.addEventListener('click', async () => {
             console.log("Attempting to save NEW match...");
             const dateValue = document.getElementById('new-match-date').value;
             let matchDateTimestamp = null;
             if (dateValue) {
                 try { matchDateTimestamp = firebase.firestore.Timestamp.fromDate(new Date(dateValue)); }
                 catch (e) { showSaveStatus('Error: Invalid Date format.', true); return; }
             } else {
                 showSaveStatus('Error: Match Date & Time are required.', true); return;
             }
             const newMatchData = {
                 date: matchDateTimestamp,
                 type: document.getElementById('new-match-type').value.trim(),
                 team1: { name: document.getElementById('new-match-team1-name').value.trim(), logo: document.getElementById('new-match-team1-logo').value.trim().toUpperCase() },
                 team2: { name: document.getElementById('new-match-team2-name').value.trim(), logo: document.getElementById('new-match-team2-logo').value.trim().toUpperCase() },
                 venue: document.getElementById('new-match-venue').value.trim(),
                 streamLink: document.getElementById('new-match-stream').value.trim()
             };
             if (!newMatchData.type || !newMatchData.team1.name || !newMatchData.team2.name) {
                 showSaveStatus('Error: Type, Team 1 Name, & Team 2 Name required.', true); return;
             }

             showSaveStatus("Saving new match...", false, 0);
             try {
                 await db.collection('matches').add(newMatchData);
                 showSaveStatus('New match added successfully!', false);
                 addMatchForm.classList.add('hidden');
                 addMatchForm.querySelectorAll('input').forEach(input => input.value = (input.id === 'new-match-stream' ? 'https://www.twitch.tv/poxelcompetitive/' : '')); // Reset form
                 loadMatchesAdmin(); // Reload list
             } catch (error) {
                 console.error("Error adding match:", error);
                 showSaveStatus(`Error adding match: ${error.message}`, true);
             }
        });
        // Save All Existing Match Changes Button
        saveMatchesChangesButton.addEventListener('click', async () => {
             console.log("Attempting to save ALL existing match changes...");
             const updates = []; let errorsFound = false;

             document.querySelectorAll('#matches-list .match-editor').forEach(editor => {
                 const id = editor.dataset.id; if (!id) return;
                 const matchData = { team1: {}, team2: {} }; let hasDateError = false;

                 const dateValue = editor.querySelector('input[data-field="date"]')?.value;
                 if (dateValue) {
                     try { matchData.date = firebase.firestore.Timestamp.fromDate(new Date(dateValue)); }
                     catch (e) {
                         console.error(`Invalid date for Match ID ${id}: ${dateValue}`, e);
                         showSaveStatus(`Error: Invalid date format for match ${id}. Changes for this match not saved.`, true);
                         hasDateError = true; errorsFound = true;
                     }
                 } else {
                     matchData.date = null; // Allow clearing the date? Or error? For now, allow null.
                     // showSaveStatus(`Warning: Date missing for match ${id}.`, true); // Optional warning
                 }

                 // Only process other fields if date is valid (or null is allowed)
                 if (!hasDateError) {
                     editor.querySelectorAll('input:not([data-field="date"])').forEach(input => {
                         const fieldPath = input.dataset.field;
                         if(fieldPath) {
                             let value = input.value.trim();
                             if (fieldPath.includes('.')) {
                                 const parts = fieldPath.split('.');
                                 if (parts.length === 2) {
                                     // Ensure nested object exists
                                     if (!matchData[parts[0]]) matchData[parts[0]] = {};
                                     matchData[parts[0]][parts[1]] = value;
                                 }
                             } else {
                                 matchData[fieldPath] = value;
                             }
                         }
                     });
                     console.log(`Queueing update for Match ID ${id}:`, matchData);
                     updates.push({ id: id, data: matchData });
                 }
             });

             if (updates.length === 0 && !errorsFound) {
                 showSaveStatus('No valid changes detected in matches.', false); return;
             }
              if (updates.length === 0 && errorsFound) {
                 showSaveStatus('No matches updated due to errors.', true); return;
             }

             showSaveStatus(`Saving changes to ${updates.length} match(es)...`, false, 0);
             const batch = db.batch();
             updates.forEach(update => {
                 const docRef = db.collection('matches').doc(update.id);
                 batch.update(docRef, update.data);
             });

             try {
                 await batch.commit();
                 showSaveStatus(`${updates.length} match(es) updated successfully!${errorsFound ? ' (Some matches skipped due to errors)' : ''}`, false);
                 loadMatchesAdmin(); // Reload to show updated data
             } catch (error) {
                 console.error("Error batch updating matches:", error);
                 showSaveStatus(`Error saving match changes: ${error.message}`, true);
             }
        });


        // --- Leaderboard Management (Largely Unchanged) ---
        async function loadLeaderboardAdmin() {
            if (!leaderboardBodyAdmin || !leaderboardLoading) { console.error("Leaderboard elements missing"); return; }
            showLoading(leaderboardLoading, true, "Loading leaderboard...");
            leaderboardBodyAdmin.innerHTML = ''; // Clear existing rows
            try {
                const snapshot = await db.collection('leaderboard').orderBy('points', 'desc').get();
                showLoading(leaderboardLoading, false); // Hide loading indicator
                let rank = 1;
                if (snapshot.empty) {
                    leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8">No players found.</td></tr>';
                    return;
                }
                snapshot.forEach(doc => {
                    const player = { id: doc.id, ...doc.data() };
                    const row = document.createElement('tr');
                    row.dataset.id = player.id;
                    row.innerHTML = `
                          <td>${rank++}</td>
                          <td><input type="text" value="${player.name || ''}" data-field="name"></td>
                          <td><input type="text" value="${player.avatar || ''}" data-field="avatar" maxlength="2"></td>
                          <td><input type="number" value="${player.matches || 0}" data-field="matches" min="0"></td>
                          <td><input type="number" value="${player.wins || 0}" data-field="wins" min="0"></td>
                          <td><input type="number" value="${player.losses || 0}" data-field="losses" min="0"></td>
                          <td><input type="number" value="${player.points || 0}" data-field="points"></td>
                          <td><button class="delete-button delete-player-button" data-id="${player.id}">Delete</button></td> <!-- Added delete-button class -->
                      `;
                    leaderboardBodyAdmin.appendChild(row);
                });
                attachPlayerActionListeners(); // Renamed for clarity

            } catch (error) {
                console.error("Error loading leaderboard:", error);
                showLoading(leaderboardLoading, false);
                leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8" style="color:red;">Error loading leaderboard.</td></tr>';
            }
        }

        function attachPlayerActionListeners() {
            leaderboardBodyAdmin.removeEventListener('click', handlePlayerActions); // Prevent duplicates
            leaderboardBodyAdmin.addEventListener('click', async (e) => {
                if (e.target.classList.contains('delete-player-button')) {
                    const id = e.target.dataset.id;
                    const row = e.target.closest('tr');
                    const playerName = row?.querySelector('input[data-field="name"]')?.value || `ID: ${id}`;

                    if (confirm(`Are you sure you want to delete player ${playerName}? This action is permanent.`)) {
                        showSaveStatus("Deleting player...", false, 0);
                        try {
                            await db.collection('leaderboard').doc(id).delete();
                            showSaveStatus('Player deleted successfully!', false);
                            row?.remove(); // Remove from UI immediately
                            // Re-rank if needed (or just reload)
                            // loadLeaderboardAdmin(); // Reloading updates ranks properly
                            updateLeaderboardRanks(); // Or just update ranks in UI
                            if(leaderboardBodyAdmin.children.length === 0 || (leaderboardBodyAdmin.children.length === 1 && leaderboardBodyAdmin.children[0].children[0].colSpan === 8)) {
                                leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8">No players found.</td></tr>';
                            }
                        } catch (error) {
                            console.error(`Error deleting player ${id}:`, error);
                            showSaveStatus(`Error deleting player: ${error.message}`, true);
                        }
                    } else { console.log("Deletion cancelled."); }
                }
            });
        }

        function updateLeaderboardRanks() {
             let rank = 1;
             leaderboardBodyAdmin.querySelectorAll('tr').forEach(row => {
                 const rankCell = row.querySelector('td:first-child');
                 if (rankCell && row.dataset.id) { // Make sure it's a player row
                     rankCell.textContent = rank++;
                 }
             });
        }

        // Add New Player Button
        addPlayerButton.addEventListener('click', () => addPlayerForm.classList.toggle('hidden'));
        // Save New Player Button
        saveNewPlayerButton.addEventListener('click', async () => {
            console.log("Attempting to save new player...");
            const nameInput = document.getElementById('new-player-name');
            const avatarInput = document.getElementById('new-player-avatar');
            const matchesInput = document.getElementById('new-player-matches');
            const winsInput = document.getElementById('new-player-wins');
            const lossesInput = document.getElementById('new-player-losses');
            const pointsInput = document.getElementById('new-player-points');

            const newPlayerData = {
                name: nameInput.value.trim(),
                avatar: avatarInput.value.trim().toUpperCase(),
                matches: parseInt(matchesInput.value) || 0,
                wins: parseInt(winsInput.value) || 0,
                losses: parseInt(lossesInput.value) || 0,
                points: parseInt(pointsInput.value) || 0
            };

            if (!newPlayerData.name) {
                showSaveStatus('Error: Player Name required.', true); return;
            }

            showSaveStatus("Saving new player...", false, 0);
            try {
                await db.collection('leaderboard').add(newPlayerData);
                showSaveStatus('New player added successfully!', false);
                addPlayerForm.classList.add('hidden');
                // Reset form fields
                nameInput.value = ''; avatarInput.value = ''; matchesInput.value = '0';
                winsInput.value = '0'; lossesInput.value = '0'; pointsInput.value = '0';
                loadLeaderboardAdmin(); // Reload list
            } catch (error) {
                console.error("Error adding player:", error);
                showSaveStatus(`Error adding player: ${error.message}`, true);
            }
        });
        // Save All Existing Leaderboard Changes Button
        saveLeaderboardChangesButton.addEventListener('click', async () => {
             console.log("Attempting to save all leaderboard changes...");
             const updates = []; let errorsFound = false;

             document.querySelectorAll('#leaderboard-body-admin tr').forEach(row => {
                 const id = row.dataset.id;
                 if (!id) return; // Skip header or non-player rows

                 const playerData = {}; let hasParsingError = false;
                 row.querySelectorAll('input').forEach(input => {
                     const field = input.dataset.field;
                     if(field) {
                         let value = input.value.trim();
                         if (input.type === 'number') {
                             const parsedValue = parseInt(value);
                             if (isNaN(parsedValue)) {
                                 console.error(`Invalid number for Player ID ${id}, field ${field}: "${value}"`);
                                 showSaveStatus(`Error: Invalid number for player ${id}/${field}. Changes for this player not saved.`, true);
                                 hasParsingError = true; errorsFound = true;
                                 value = 0; // Default to 0 on error? Or skip update? Skipping row for now.
                             } else {
                                 value = parsedValue;
                             }
                         } else if (field === 'avatar') {
                             value = value.toUpperCase();
                         }
                         playerData[field] = value;
                     }
                 });

                 // Only add to updates if no errors occurred for this player
                 if (!hasParsingError) {
                     console.log(`Queueing update for Player ID ${id}:`, playerData);
                     updates.push({ id: id, data: playerData });
                 }
             });

             if (updates.length === 0 && !errorsFound) {
                 showSaveStatus('No valid changes detected in leaderboard.', false); return;
             }
             if (updates.length === 0 && errorsFound) {
                 showSaveStatus('No players updated due to errors.', true); return;
             }

             showSaveStatus(`Saving changes to ${updates.length} player(s)...`, false, 0);
             const batch = db.batch();
             updates.forEach(update => {
                 const docRef = db.collection('leaderboard').doc(update.id);
                 batch.update(docRef, update.data);
             });

             try {
                 await batch.commit();
                 showSaveStatus(`${updates.length} player(s) updated successfully!${errorsFound ? ' (Some players skipped due to errors)' : ''}`, false);
                 loadLeaderboardAdmin(); // Reload to reflect changes and potentially re-sort/re-rank
             } catch (error) {
                 console.error("Error batch updating leaderboard:", error);
                 showSaveStatus(`Error saving leaderboard changes: ${error.message}`, true);
             }
         });

        // --- Tournament Bracket Management (REWORKED LOGIC) ---

        // Load Summary of Existing Brackets
        async function loadCreatedBracketsSummary() {
            if (!createdBracketsList || !createdBracketsLoading || !noBracketsMessage) return;
            showLoading(createdBracketsLoading, true, "Loading existing brackets...");
            createdBracketsList.innerHTML = ''; // Clear previous summaries
            noBracketsMessage.classList.add('hidden');
            let bracketsFound = false;

            try {
                const bracketTypes = ['pro', 'novice'];
                const promises = bracketTypes.map(type => db.collection('brackets').doc(type).get());
                const snapshots = await Promise.all(promises);

                snapshots.forEach((docSnap, index) => {
                    const type = bracketTypes[index];
                    if (docSnap.exists()) {
                        bracketsFound = true;
                        const data = docSnap.data();
                        const rounds = data.rounds || [];
                        let matchCount = 0;
                        rounds.forEach(r => matchCount += (r.matches?.length || 0));
                        const summaryDiv = document.createElement('div');
                        summaryDiv.classList.add('bracket-summary-item');
                        summaryDiv.innerHTML = `
                             <div>
                                 <h4>${type === 'pro' ? 'Pro Tourney' : 'Novice Tourney'}</h4>
                                 <span>${rounds.length} Round(s), ${matchCount} Match(es)</span>
                             </div>
                             <button class="delete-button delete-bracket-button" data-bracket-type="${type}">Delete ${type === 'pro' ? 'Pro' : 'Novice'} Bracket</button>
                         `;
                        createdBracketsList.appendChild(summaryDiv);
                    }
                });

                showLoading(createdBracketsLoading, false); // Hide loading
                if (!bracketsFound) {
                    noBracketsMessage.classList.remove('hidden');
                }
                attachBracketSummaryActionListeners();

            } catch (error) {
                console.error("Error loading bracket summaries:", error);
                showLoading(createdBracketsLoading, false);
                createdBracketsList.innerHTML = `<p style="color:red;">Error loading bracket summaries.</p>`;
            }
        }

        // Attach listeners for delete buttons in the summary list
        function attachBracketSummaryActionListeners() {
            createdBracketsList.removeEventListener('click', handleBracketSummaryActions); // Prevent duplicates
            createdBracketsList.addEventListener('click', async (e) => {
                if (e.target.classList.contains('delete-bracket-button')) {
                    const bracketType = e.target.dataset.bracketType;
                    if (confirm(`ARE YOU SURE you want to permanently delete the entire ${bracketType} bracket?`)) {
                        showSaveStatus(`Deleting ${bracketType} bracket...`, false, 0);
                        try {
                            await db.collection('brackets').doc(bracketType).delete();
                            showSaveStatus(`${bracketType} bracket deleted successfully!`, false);
                            e.target.closest('.bracket-summary-item')?.remove(); // Remove from UI
                            if(createdBracketsList.children.length === 0) {
                                noBracketsMessage.classList.remove('hidden');
                            }
                            // If the deleted bracket was being edited, close the editor
                            if (bracketEditorForm.dataset.editingType === bracketType && !bracketEditorForm.classList.contains('hidden')) {
                                cancelBracketEditorButton.click(); // Simulate cancel click
                                showSaveStatus(`Editor closed as the ${bracketType} bracket was deleted.`, false);
                            }
                        } catch (error) {
                            console.error(`Error deleting ${bracketType} bracket:`, error);
                            showSaveStatus(`Error deleting ${bracketType} bracket: ${error.message}`, true);
                        }
                    }
                }
            });
        }

        // "Edit/Create Selected Bracket" Button Action
        editCreateBracketButton.addEventListener('click', () => {
            const selectedBracketType = bracketSelect.value;
            loadBracketIntoEditor(selectedBracketType);
        });

        // Load data for the selected bracket into the editor form
        async function loadBracketIntoEditor(bracketType) {
            if (!bracketEditorForm || !bracketEditorContent || !bracketEditorLoading || !bracketEditorHeading) return;
            console.log(`--- Loading bracket for editing: ${bracketType} ---`);

            bracketEditorHeading.textContent = `Editing: ${bracketType === 'pro' ? 'Pro' : 'Novice'} Tourney`;
            bracketEditorForm.dataset.editingType = bracketType; // Store which bracket is being edited
            bracketEditorContent.innerHTML = ''; // Clear previous editor content
            showLoading(bracketEditorLoading, true, `Loading ${bracketType} bracket data...`);
            bracketEditorForm.classList.remove('hidden'); // Show the editor form

            try {
                const docRef = db.collection('brackets').doc(bracketType);
                const docSnap = await docRef.get();

                let bracketData = { rounds: [] }; // Default to empty structure for creation
                if (docSnap.exists()) {
                    console.log(`[${bracketType}] Found existing data.`);
                    bracketData = docSnap.data();
                    // Ensure rounds is always an array
                    if (!Array.isArray(bracketData.rounds)) {
                         console.warn(`[${bracketType}] 'rounds' field was not an array. Resetting.`);
                         bracketData.rounds = [];
                    }
                } else {
                    console.log(`[${bracketType}] No existing data found. Editor will start empty for creation.`);
                    bracketEditorHeading.textContent += " (Creating New)"; // Indicate creation
                }

                renderBracketEditorForm(bracketData, bracketType); // Render the form content
                showLoading(bracketEditorLoading, false); // Hide loading indicator

            } catch (error) {
                console.error(`--- ERROR loading ${bracketType} bracket into editor: ---`, error);
                bracketEditorContent.innerHTML = `<p style="color:red;">Error loading ${bracketType} bracket data. Cannot edit.</p>`;
                showLoading(bracketEditorLoading, false);
                // Consider disabling save button or adding a retry?
            }
        }

        // Render the actual rounds and matches inside the editor form
        function renderBracketEditorForm(bracketData, bracketType) {
            console.log(`Rendering editor form content for ${bracketType}`);
            if (!bracketEditorContent) return;

            bracketEditorContent.innerHTML = ''; // Clear any previous content (like error messages)

            if (!bracketData.rounds || bracketData.rounds.length === 0) {
                console.log("No rounds found in data. Displaying 'No rounds' message in editor.");
                bracketEditorContent.innerHTML = '<p class="no-rounds-message">No rounds in this bracket yet. Click "Add Round" to start.</p>';
            } else {
                console.log(`Rendering ${bracketData.rounds.length} rounds into editor...`);
                bracketData.rounds.forEach((round, roundIndex) => {
                    const roundDiv = createRoundEditorElement(round, roundIndex);
                    bracketEditorContent.appendChild(roundDiv);
                });
            }
            // Attach event listeners for actions WITHIN the editor form
            attachBracketEditorActionListeners();
        }

        // Creates the HTML element for a single round in the editor
        function createRoundEditorElement(round, roundIndex) {
             const roundDiv = document.createElement('div');
             roundDiv.classList.add('bracket-round');
             roundDiv.dataset.index = roundIndex;
             roundDiv.innerHTML = `
                 <h4>Round ${roundIndex + 1}: <input type="text" value="${round.name || `Round ${roundIndex + 1}`}" class="round-name" placeholder="Round Name">
                 <button class="delete-button delete-round-button" data-index="${roundIndex}">Delete Round</button></h4>
                 <div class="matches-in-round">
                     ${(!round.matches || round.matches.length === 0) ? '<p class="no-matches-message">No matches yet.</p>' : ''}
                 </div>
                 <button class="add-match-to-round-button" data-round-index="${roundIndex}">Add Match to this Round</button>
             `;

             const matchesContainer = roundDiv.querySelector('.matches-in-round');
             if (round.matches && round.matches.length > 0) {
                 round.matches.forEach((match, matchIndex) => {
                     const matchDiv = createMatchEditorElement(match, roundIndex, matchIndex);
                     matchesContainer.appendChild(matchDiv);
                 });
             }
             return roundDiv;
        }

        // Creates the HTML element for a single match in the editor
         function createMatchEditorElement(match, roundIndex, matchIndex) {
             const matchDiv = document.createElement('div');
             matchDiv.classList.add('bracket-match');
             matchDiv.dataset.roundIndex = roundIndex;
             matchDiv.dataset.matchIndex = matchIndex;
             // Use nullish coalescing (??) for scores to handle 0 correctly, default to empty string for input
             const team1Score = match.team1?.score ?? '';
             const team2Score = match.team2?.score ?? '';

             matchDiv.innerHTML = `
                 <h5>Match ${matchIndex + 1}
                 <button class="delete-button delete-match-from-round-button" data-round-index="${roundIndex}" data-match-index="${matchIndex}">Delete Match</button>
                 </h5>
                 <label>Team 1 Name:</label> <input type="text" value="${match.team1?.name || ''}" class="bracket-team1-name" placeholder="TBD/Team Name">
                 <label>Team 1 Score:</label> <input type="number" value="${team1Score}" class="bracket-team1-score" placeholder="-">
                 <label>Team 2 Name:</label> <input type="text" value="${match.team2?.name || ''}" class="bracket-team2-name" placeholder="TBD/Team Name">
                 <label>Team 2 Score:</label> <input type="number" value="${team2Score}" class="bracket-team2-score" placeholder="-">
                 <label>Winner Team Name:</label> <input type="text" value="${match.winnerName || ''}" class="bracket-winner-name" placeholder="Enter Winner Name">
                 <label>Completed:</label> <input type="checkbox" ${match.completed ? 'checked' : ''} class="bracket-match-completed">
             `;
             return matchDiv;
         }


        // Attach listeners for buttons INSIDE the bracket editor form (add/delete round/match)
        function attachBracketEditorActionListeners() {
            console.log("Attaching/Re-attaching listeners for bracket editor form actions...");
            if (!bracketEditorForm) return;

            // Use event delegation on the form content area
            bracketEditorContent.removeEventListener('click', handleBracketEditorContentClick); // Prevent multiple listeners
            bracketEditorContent.addEventListener('click', handleBracketEditorContentClick);
        }

        // Handle clicks delegated from bracketEditorContent
        function handleBracketEditorContentClick(event) {
            const target = event.target;
            console.log("Bracket editor content click detected on:", target);

            if (target.classList.contains('delete-round-button')) {
                const roundIndex = target.dataset.index;
                console.log("Delete Round button (UI only) click handled for index:", roundIndex);
                deleteBracketRoundUI(roundIndex);
            } else if (target.classList.contains('add-match-to-round-button')) {
                const roundIndex = target.dataset.roundIndex;
                console.log("Add Match button click handled for round index:", roundIndex);
                addBracketMatchUI(roundIndex);
            } else if (target.classList.contains('delete-match-from-round-button')) {
                const roundIndex = target.dataset.roundIndex;
                const matchIndex = target.dataset.matchIndex;
                console.log("Delete Match button click handled for R:", roundIndex, "M:", matchIndex);
                deleteBracketMatchUI(roundIndex, matchIndex); // We'll just remove from UI here, actual save does the data change. OR keep the immediate DB delete? Decide. Let's KEEP immediate DB delete for matches as it's a smaller unit of work.
                // deleteBracketMatchFromDBAndUI(roundIndex, matchIndex); // Use this if you want immediate DB deletion
            }
        }

        // --- Bracket Editor UI Manipulation Functions ---

        // Add Round button (overall form button)
        addRoundToEditorButton.addEventListener('click', () => {
            console.log("Add Round button clicked for the editor form.");
            if (!bracketEditorContent) return;
            const newRoundIndex = bracketEditorContent.querySelectorAll('.bracket-round').length;
            console.log(`Adding new round UI at index: ${newRoundIndex}`);

            const roundDiv = createRoundEditorElement({ name: `New Round ${newRoundIndex + 1}`, matches: [] }, newRoundIndex); // Create with default name

            const noRoundsMsg = bracketEditorContent.querySelector('.no-rounds-message');
            if (noRoundsMsg) {
                console.log("Removing 'No rounds' message.");
                noRoundsMsg.remove();
            }
            bracketEditorContent.appendChild(roundDiv);
            // Event delegation handles new button listeners automatically
        });

        // Delete Round (UI Only)
        function deleteBracketRoundUI(roundIndex) {
            console.log(`Attempting to delete round UI index: ${roundIndex}`);
            if (!bracketEditorContent) return;

            // No confirmation needed here as it's UI only until Save
            const roundElement = bracketEditorContent.querySelector(`.bracket-round[data-index="${roundIndex}"]`);
            if (roundElement) {
                roundElement.remove();
                console.log(`Removed round element UI index: ${roundIndex}`);
                // Re-index subsequent rounds in the UI
                reindexBracketEditorUI();
                if (bracketEditorContent.children.length === 0) {
                    bracketEditorContent.innerHTML = '<p class="no-rounds-message">No rounds in this bracket yet. Click "Add Round" to start.</p>';
                }
            } else {
                console.warn(`Could not find round element UI to delete index: ${roundIndex}`);
            }
        }

        // Add Match (UI Only)
        function addBracketMatchUI(roundIndex) {
            console.log('--- addBracketMatchUI called --- roundIndex:', roundIndex);
            if (!bracketEditorContent) return;

            const roundElement = bracketEditorContent.querySelector(`.bracket-round[data-index="${roundIndex}"]`);
            if (!roundElement) { console.error('Could not find round container UI.'); return; }

            const matchesContainer = roundElement.querySelector('.matches-in-round');
            if (!matchesContainer) { console.error('Could not find matches container UI.'); return; }

            const newMatchIndex = matchesContainer.querySelectorAll('.bracket-match').length;
            console.log('Calculated newMatchIndex UI:', newMatchIndex);

            try {
                // Pass empty object for a new match
                const matchDiv = createMatchEditorElement({}, roundIndex, newMatchIndex);
                const noMatchesMsg = matchesContainer.querySelector('.no-matches-message');
                if (noMatchesMsg) {
                    console.log('Removing "No matches" message UI');
                    noMatchesMsg.remove();
                }
                matchesContainer.appendChild(matchDiv);
                console.log('--- addBracketMatchUI finished successfully ---');
            } catch (error) {
                 console.error("Error during addBracketMatchUI execution:", error);
                 showSaveStatus('An error occurred while adding the match editor UI.', true);
            }
        }

        // Delete Match (UI Only)
        function deleteBracketMatchUI(roundIndex, matchIndex) {
             console.log(`Attempting to delete match UI R${roundIndex} M${matchIndex}`);
             if (!bracketEditorContent) { console.error("Delete Error: bracketEditorContent not found"); return; }

             const matchElement = bracketEditorContent.querySelector(`.bracket-match[data-round-index="${roundIndex}"][data-match-index="${matchIndex}"]`);
             if (matchElement) {
                 const container = matchElement.parentElement;
                 matchElement.remove();
                 console.log(`Removed match element UI R${roundIndex} M${matchIndex}`);
                 // Re-index remaining matches in this round's UI
                 reindexBracketEditorUI(); // Re-index everything to be safe
                 if (container && container.children.length === 0 && !container.querySelector('.no-matches-message')) {
                     const p = document.createElement('p');
                     p.classList.add('no-matches-message');
                     p.textContent = 'No matches yet.';
                     container.appendChild(p);
                 }
             } else {
                 console.warn(`Could not find match element UI to remove R${roundIndex} M${matchIndex}.`);
             }
         }

         // Re-index Rounds and Matches in the Editor UI after deletion
         function reindexBracketEditorUI() {
             if (!bracketEditorContent) return;
             console.log("Re-indexing bracket editor UI...");

             let currentRoundIdx = 0;
             bracketEditorContent.querySelectorAll('.bracket-round').forEach((roundDiv) => {
                 const oldRoundIndex = roundDiv.dataset.index;
                 roundDiv.dataset.index = currentRoundIdx;
                 // Update heading number
                 const heading = roundDiv.querySelector('h4');
                 if (heading) heading.firstChild.textContent = `Round ${currentRoundIdx + 1}: `;
                 // Update button indices
                 const delRoundBtn = roundDiv.querySelector('.delete-round-button');
                 if (delRoundBtn) delRoundBtn.dataset.index = currentRoundIdx;
                 const addMatchBtn = roundDiv.querySelector('.add-match-to-round-button');
                 if (addMatchBtn) addMatchBtn.dataset.roundIndex = currentRoundIdx;

                 console.log(` Round UI: ${oldRoundIndex} -> ${currentRoundIdx}`);

                 let currentMatchIdx = 0;
                 const matchesContainer = roundDiv.querySelector('.matches-in-round');
                 if (matchesContainer) {
                     matchesContainer.querySelectorAll('.bracket-match').forEach((matchDiv) => {
                         const oldMatchIndex = matchDiv.dataset.matchIndex;
                         matchDiv.dataset.roundIndex = currentRoundIdx; // Update round index too
                         matchDiv.dataset.matchIndex = currentMatchIdx;
                         // Update match heading number
                         const matchHeading = matchDiv.querySelector('h5');
                         if (matchHeading) matchHeading.firstChild.textContent = `Match ${currentMatchIdx + 1} `;
                         // Update delete match button indices
                         const delMatchBtn = matchDiv.querySelector('.delete-match-from-round-button');
                         if (delMatchBtn) {
                             delMatchBtn.dataset.roundIndex = currentRoundIdx;
                             delMatchBtn.dataset.matchIndex = currentMatchIdx;
                         }
                         console.log(`   Match UI: R${oldRoundIndex}M${oldMatchIndex} -> R${currentRoundIdx}M${currentMatchIdx}`);
                         currentMatchIdx++;
                     });
                 }
                 currentRoundIdx++;
             });
         }

        // Save Bracket Changes (from the editor form)
        saveBracketEditorChangesButton.addEventListener('click', async () => {
            const bracketType = bracketEditorForm?.dataset.editingType;
            console.log(`Attempting to save bracket changes for: ${bracketType}`);
            if (!bracketType || !bracketEditorContent) {
                showSaveStatus('Error: Cannot save. Bracket type or editor content missing.', true);
                return;
            }

            const bracketData = { rounds: [] };
            let errorInData = false;

            bracketEditorContent.querySelectorAll('.bracket-round').forEach((roundDiv, roundIndex) => {
                const roundNameInput = roundDiv.querySelector('.round-name');
                const round = {
                    name: roundNameInput ? roundNameInput.value.trim() : `Round ${roundIndex + 1}`,
                    matches: []
                };
                 console.log(`  Processing Round ${roundIndex + 1} ('${round.name}')`);

                roundDiv.querySelectorAll('.bracket-match').forEach((matchDiv, matchIndex) => {
                    const t1NameInput = matchDiv.querySelector('.bracket-team1-name');
                    const t1ScoreInput = matchDiv.querySelector('.bracket-team1-score');
                    const t2NameInput = matchDiv.querySelector('.bracket-team2-name');
                    const t2ScoreInput = matchDiv.querySelector('.bracket-team2-score');
                    const winnerNameInput = matchDiv.querySelector('.bracket-winner-name');
                    const completedCheckbox = matchDiv.querySelector('.bracket-match-completed');

                    const t1Name = t1NameInput ? t1NameInput.value.trim() : '';
                    const t2Name = t2NameInput ? t2NameInput.value.trim() : '';
                    const t1ScoreRaw = t1ScoreInput ? t1ScoreInput.value : '';
                    const t2ScoreRaw = t2ScoreInput ? t2ScoreInput.value : '';
                    const winnerName = winnerNameInput ? winnerNameInput.value.trim() : null;
                    const completed = completedCheckbox ? completedCheckbox.checked : false;

                    // Parse scores, allowing empty strings -> null
                    let t1Score = null;
                    if (t1ScoreRaw !== '') {
                        t1Score = parseInt(t1ScoreRaw);
                        if (isNaN(t1Score)) {
                            showSaveStatus(`Error: Invalid score for Team 1 in Round ${roundIndex + 1}, Match ${matchIndex + 1}.`, true);
                            errorInData = true; t1Score = null; // Set to null on error
                        }
                    }
                    let t2Score = null;
                    if (t2ScoreRaw !== '') {
                        t2Score = parseInt(t2ScoreRaw);
                        if (isNaN(t2Score)) {
                            showSaveStatus(`Error: Invalid score for Team 2 in Round ${roundIndex + 1}, Match ${matchIndex + 1}.`, true);
                            errorInData = true; t2Score = null; // Set to null on error
                        }
                    }

                    const match = {
                        team1: { name: t1Name, score: t1Score },
                        team2: { name: t2Name, score: t2Score },
                        winnerName: winnerName || null, // Ensure null if empty
                        completed: completed,
                        winner: null // // Deprecated? Keep winnerName? Let's rely on winnerName. We can derive 'winner' on the frontend if needed.
                    };

                     console.log(`    Match ${matchIndex + 1}: T1(${match.team1.name}, ${match.team1.score}) T2(${match.team2.name}, ${match.team2.score}) W: ${match.winnerName} Done: ${match.completed}`);

                    round.matches.push(match);
                });
                bracketData.rounds.push(round);
            });

            if (errorInData) {
                showSaveStatus('Save aborted due to invalid data (e.g., non-numeric scores). Please correct the errors.', true);
                console.error("Save aborted due to data errors.");
                return;
            }

            console.log(`Compiled bracket data for saving (${bracketType}):`, JSON.parse(JSON.stringify(bracketData))); // Deep copy for logging
            showSaveStatus(`Saving ${bracketType} bracket...`, false, 0);

            try {
                // Use set with merge:false to completely overwrite the document
                await db.collection('brackets').doc(bracketType).set(bracketData);
                console.log(`${bracketType} bracket saved successfully.`);
                showSaveStatus(`${bracketType} bracket saved successfully!`, false);
                bracketEditorForm.classList.add('hidden'); // Hide editor on successful save
                bracketEditorContent.innerHTML = ''; // Clear editor content
                loadCreatedBracketsSummary(); // Reload the summary list to reflect changes/creation
            } catch (error) {
                console.error(`Error saving ${bracketType} bracket:`, error);
                showSaveStatus(`Error saving ${bracketType} bracket: ${error.message}`, true);
            }
        });

        // Cancel Button for the bracket editor form
        cancelBracketEditorButton.addEventListener('click', () => {
            console.log("Cancelling bracket edit.");
            bracketEditorForm.classList.add('hidden');
            bracketEditorContent.innerHTML = ''; // Clear content
            bracketEditorForm.removeAttribute('data-editing-type'); // Remove editing context
            showSaveStatus(''); // Clear any previous status
        });


        // --- Initial Load Call ---
        console.log("Admin script initialized. Waiting for authentication state...");
        // loadAdminData() is called by the onAuthStateChanged handler

    </script>

</body>
</html>
