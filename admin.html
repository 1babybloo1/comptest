<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Poxel Competitive - Admin Panel</title>
    <style>
        :root {
            --dark: #121212;
            --dark-accent: #1e1e1e;
            --orange: #ff5722;
            --text: #f5f5f5;
            --text-secondary: #aaaaaa;
            --green-live: #2ecc71; /* Added live indicator color */
        }
        body { background-color: var(--dark); color: var(--text); font-family: sans-serif; padding: 20px; }
        #login-container, #admin-panel { background-color: var(--dark-accent); padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        h1, h2 { color: var(--orange); }
        button { background-color: var(--orange); color: white; padding: 10px 15px; border: none; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { opacity: 0.9; }
        #logout-button { background-color: #555; }
        .admin-section { margin-top: 20px; border-top: 1px solid #444; padding-top: 20px; }
        label { display: block; margin-bottom: 5px; color: var(--text-secondary); }
        input[type="text"], input[type="datetime-local"], input[type="number"], textarea, select { /* Added select */
            width: calc(95% - 18px); /* Adjust width considering padding/border */
            padding: 8px;
            margin-bottom: 10px;
            background-color: #333;
            border: 1px solid #555;
            color: var(--text);
            border-radius: 4px;
        }
        input[type="checkbox"] {
            margin-right: 5px;
            vertical-align: middle;
        }
        label[for] {
            cursor: pointer; /* Indicate checkbox label is clickable */
        }

        .hidden { display: none; }
        .fade-in { animation: fadeIn 0.5s ease forwards; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        table { width: 100%; border-collapse: collapse; margin-top: 15px; }
        th, td { border: 1px solid #444; padding: 8px; text-align: left; }
        th { background-color: rgba(255, 87, 34, 0.1); color: var(--orange); }

        .match-editor, .player-editor {
             margin-bottom: 15px; padding: 10px; border: 1px dashed #555; border-radius: 5px;
        }

        /* --- Bracket Editor Styles (Keep Existing) --- */
        #bracket-editor { display: flex; overflow-x: auto; padding-bottom: 15px; gap: 20px; }
        .bracket-round-column { flex: 0 0 300px; min-width: 250px; padding: 15px; border: 1px solid #444; border-radius: 8px; background-color: var(--dark-accent); display: flex; flex-direction: column; gap: 15px; }
        .bracket-round-column h4 { margin-top: 0; padding-bottom: 10px; border-bottom: 1px dashed #555; display: flex; justify-content: space-between; align-items: center; }
        .bracket-round-column h4 input[type="text"] { flex-grow: 1; margin-right: 10px; padding: 5px; width: auto; }
        .bracket-match-editor { padding: 10px; border: 1px solid #555; border-radius: 4px; background-color: var(--dark); display: flex; flex-direction: column; gap: 5px; }
        .bracket-match-editor h5 { margin-top: 0; margin-bottom: 5px; display: flex; justify-content: space-between; align-items: center; font-size: 1em; }
        .bracket-match-editor h5 button { padding: 3px 8px; font-size: 0.8em; margin: 0; background-color: #c0392b; }
        .bracket-round-column h4 button { padding: 3px 8px; font-size: 0.8em; margin: 0; background-color: #c0392b; }
        .bracket-match-editor label { font-size: 0.9em; margin-bottom: 0; }
        .bracket-match-editor input[type="text"], .bracket-match-editor input[type="number"] { width: calc(100% - 18px); padding: 4px; margin-bottom: 5px; font-size: 0.9em; }
        .bracket-match-editor .checkbox-label { display: flex; align-items: center; margin-top: 5px; font-size: 0.9em; }
        .bracket-match-editor .checkbox-label input[type="checkbox"] { margin-right: 5px; margin-bottom: 0; }
        .bracket-controls { margin-top: 20px; padding-top: 15px; border-top: 1px solid #444; }
        .bracket-controls button { margin-right: 10px; }
        .loading-indicator { font-style: italic; color: var(--text-secondary); padding: 10px; text-align: center; width: 100%; box-sizing: border-box; }
        /* --- End Bracket Editor Styles --- */

        /* --- START: Online Users Presence Styles --- */
        #online-users-section {
            margin-bottom: 20px;
            padding: 15px;
            background-color: var(--dark-accent);
            border-radius: 8px;
            border: 1px solid #444;
        }
        #online-users-section h4 {
            margin-top: 0;
            margin-bottom: 15px;
            color: var(--text-secondary);
            font-size: 0.9em;
            font-weight: normal;
            border-bottom: 1px dashed #555;
            padding-bottom: 10px;
        }
        #online-users-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px; /* Spacing between user indicators */
        }
        .user-presence-indicator {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }
        .user-presence-circle {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: var(--orange); /* Default background */
            color: var(--dark);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
            border: 3px solid transparent; /* Placeholder for live border */
            box-sizing: border-box;
            text-transform: uppercase;
        }
        .user-presence-circle.live {
            border-color: var(--green-live); /* Green border when live */
        }
        .user-presence-name {
            font-size: 0.8em;
            color: var(--text-secondary);
            max-width: 80px; /* Prevent long names from breaking layout */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        /* --- END: Online Users Presence Styles --- */

    </style>
</head>
<body>

<h1>Poxel Competitive - Admin</h1>

<!-- Login Section -->
<div id="login-container">
    <h2>Admin Login</h2>
    <p>Please log in with your authorized Google account.</p>
    <button id="login-button">Login with Google</button>
    <p id="login-error" style="color: red;"></p>
    <p id="auth-check-message" style="color: orange;"></p>
</div>

<!-- Admin Panel (Initially Hidden) -->
<div id="admin-panel" class="hidden">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <h2>Management Dashboard</h2>
        <div>
            <span id="user-info" style="margin-right: 15px;"></span>
            <button id="logout-button">Logout</button>
        </div>
    </div>

    <!-- START: Online Users Section -->
    <div id="online-users-section">
        <h4>Online Admins:</h4>
        <div id="online-users-container">
            <div class="loading-indicator">Loading presence...</div>
            <!-- Online users will be rendered here -->
        </div>
    </div>
    <!-- END: Online Users Section -->

    <p style="color: lightgreen;" id="save-status"></p>

    <!-- Upcoming Matches Management -->
    <div class="admin-section">
        <h3>Upcoming Matches Management</h3>
        <div id="matches-list"></div>
        <button id="add-match-button">Add New Match</button>
        <div id="add-match-form" class="match-editor hidden">
             <h4>New Match Details</h4>
             <label for="new-match-date">Date & Time:</label>
             <input type="datetime-local" id="new-match-date">
             <label for="new-match-type">Type (e.g., Quarterfinals):</label>
             <input type="text" id="new-match-type">
             <label for="new-match-team1-name">Team 1 Name:</label>
             <input type="text" id="new-match-team1-name">
             <label for="new-match-team1-logo">Team 1 Logo (Initials):</label>
             <input type="text" id="new-match-team1-logo" maxlength="2">
             <label for="new-match-team2-name">Team 2 Name:</label>
             <input type="text" id="new-match-team2-name">
             <label for="new-match-team2-logo">Team 2 Logo (Initials):</label>
             <input type="text" id="new-match-team2-logo" maxlength="2">
             <label for="new-match-venue">Venue:</label>
             <input type="text" id="new-match-venue">
             <label for="new-match-stream">Stream Link:</label>
             <input type="text" id="new-match-stream" value="https://www.twitch.tv/poxelcompetitive/">
             <button id="save-new-match">Save New Match</button>
             <button type="button" onclick="document.getElementById('add-match-form').classList.add('hidden')">Cancel</button>
        </div>
        <button id="save-matches-changes">Save All Match Changes</button>
    </div>

    <!-- Leaderboard Management -->
    <div class="admin-section">
        <h3>Leaderboard Management</h3>
        <div id="leaderboard-list">
             <table>
                 <thead>
                     <tr>
                         <th>Rank</th><th>Player Name</th><th>Avatar</th><th>Matches</th><th>Wins</th><th>Losses</th><th>Points</th><th>Actions</th>
                     </tr>
                 </thead>
                 <tbody id="leaderboard-body-admin"></tbody>
             </table>
        </div>
         <button id="add-player-button">Add New Player</button>
         <div id="add-player-form" class="player-editor hidden">
             <h4>New Player Details</h4>
             <label>Name:</label><input type="text" id="new-player-name">
             <label>Avatar (Initials):</label><input type="text" id="new-player-avatar" maxlength="2">
             <label>Matches:</label><input type="number" id="new-player-matches" value="0" min="0">
             <label>Wins:</label><input type="number" id="new-player-wins" value="0" min="0">
             <label>Losses:</label><input type="number" id="new-player-losses" value="0" min="0">
             <label>Points:</label><input type="number" id="new-player-points" value="0">
             <button id="save-new-player">Save New Player</button>
             <button type="button" onclick="document.getElementById('add-player-form').classList.add('hidden')">Cancel</button>
        </div>
        <button id="save-leaderboard-changes">Save Leaderboard Changes</button>
    </div>

    <!-- Tournament Bracket Management -->
    <div class="admin-section">
        <h3>Tournament Bracket Management</h3>
        <label for="bracket-select">Select Bracket:</label>
        <select id="bracket-select">
            <option value="pro">Pro Tourney</option>
            <option value="novice">Novice Tourney</option>
        </select>
         <div id="bracket-loading-indicator" class="loading-indicator hidden">Loading...</div>
        <div id="bracket-editor"></div>
        <div class="bracket-controls">
             <button id="add-round-button">Add New Round</button>
             <button id="save-bracket-changes">Save Bracket Changes</button>
              <p><i>Note: This view arranges rounds horizontally...</i></p>
        </div>
    </div>

</div>

<!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-firestore.js"></script>

<script>
    // --- START OF SCRIPT --- //

    const firebaseConfig = {
          apiKey: "AIzaSyDWFPys8dbSgis98tbm5PVqMuHqnCpPIxI",
          authDomain: "poxelcomp.firebaseapp.com",
          projectId: "poxelcomp",
          storageBucket: "poxelcomp.firebasestorage.app",
          messagingSenderId: "620490990104",
          appId: "1:620490990104:web:709023eb464c7d886b996d",
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const googleProvider = new firebase.auth.GoogleAuthProvider();

    // --- DOM Elements ---
    const loginContainer = document.getElementById('login-container');
    const adminPanel = document.getElementById('admin-panel');
    const loginButton = document.getElementById('login-button');
    const logoutButton = document.getElementById('logout-button');
    const userInfo = document.getElementById('user-info');
    const loginError = document.getElementById('login-error');
    const authCheckMessage = document.getElementById('auth-check-message'); // Added
    const saveStatus = document.getElementById('save-status');

    // Presence UI
    const onlineUsersContainer = document.getElementById('online-users-container');

    // Other sections (Matches, Leaderboard, Bracket)
    const matchesList = document.getElementById('matches-list');
    const addMatchButton = document.getElementById('add-match-button');
    const addMatchForm = document.getElementById('add-match-form');
    const saveNewMatchButton = document.getElementById('save-new-match');
    const saveMatchesChangesButton = document.getElementById('save-matches-changes');
    const leaderboardList = document.getElementById('leaderboard-list');
    const leaderboardBodyAdmin = document.getElementById('leaderboard-body-admin');
    const addPlayerButton = document.getElementById('add-player-button');
    const addPlayerForm = document.getElementById('add-player-form');
    const saveNewPlayerButton = document.getElementById('save-new-player');
    const saveLeaderboardChangesButton = document.getElementById('save-leaderboard-changes');
    const bracketSelect = document.getElementById('bracket-select');
    const bracketEditor = document.getElementById('bracket-editor');
    const bracketLoadingIndicator = document.getElementById('bracket-loading-indicator');
    const addRoundButton = document.getElementById('add-round-button');
    const saveBracketChangesButton = document.getElementById('save-bracket-changes');

    // --- Global State ---
    let currentBracketData = { rounds: [] };
    let currentBracketType = 'pro';
    let authorizedAdminUIDs = new Set(); // Stores UIDs of authorized admins
    let currentUserId = null; // Store current user's UID
    let presenceUpdateInterval = null; // Interval timer for updating 'lastSeen'
    let onlineUsersListenerUnsubscribe = null; // Function to detach the presence listener

    // --- Authorization Check ---
    async function checkAdminAuthorization(uid) {
        console.log(`Checking authorization for UID: ${uid}`);
        authCheckMessage.textContent = 'Checking authorization...';
        authCheckMessage.style.color = 'orange';
        try {
            // --- Method 1: Check against an 'admins' collection ---
            const adminDoc = await db.collection('admins').doc(uid).get();
            if (adminDoc.exists) {
                console.log(`UID ${uid} is authorized.`);
                authorizedAdminUIDs.add(uid); // Add self to known authorized set
                 authCheckMessage.textContent = ''; // Clear message on success
                return true;
            }

            // --- Method 2: Check against a list in a config doc (alternative) ---
            // const configDoc = await db.collection('admin_config').doc('authorized_users').get();
            // if (configDoc.exists && configDoc.data().uids?.includes(uid)) {
            //     console.log(`UID ${uid} is authorized via config.`);
            //     authorizedAdminUIDs.add(uid); // Add self
            //      authCheckMessage.textContent = '';
            //     return true;
            // }

            console.log(`UID ${uid} is NOT authorized.`);
            authCheckMessage.textContent = 'Access Denied: Your account is not authorized for the admin panel.';
            authCheckMessage.style.color = 'red';
            return false;

        } catch (error) {
            console.error("Error checking admin authorization:", error);
            authCheckMessage.textContent = 'Error checking authorization. Please try again.';
            authCheckMessage.style.color = 'red';
            return false;
        }
    }

    // --- Presence Management ---
    const PRESENCE_COLLECTION = 'online_users';
    const PRESENCE_TIMEOUT_MS = 90 * 1000; // 90 seconds - consider user inactive after this
    const PRESENCE_UPDATE_INTERVAL_MS = 60 * 1000; // Update lastSeen every 60 seconds

    async function registerPresence(user) {
        if (!user || !user.uid) return;
        currentUserId = user.uid; // Store UID globally
        const presenceRef = db.collection(PRESENCE_COLLECTION).doc(user.uid);
        const userData = {
            uid: user.uid,
            email: user.email,
            displayName: user.displayName || user.email.split('@')[0], // Use display name or derive from email
            lastSeen: firebase.firestore.FieldValue.serverTimestamp()
        };

        try {
            console.log(`Registering presence for ${user.email} (UID: ${user.uid})`);
            await presenceRef.set(userData, { merge: true }); // Use set with merge to create/update

            // Start periodic update
            if (presenceUpdateInterval) clearInterval(presenceUpdateInterval); // Clear previous interval if any
            presenceUpdateInterval = setInterval(async () => {
                try {
                    // Only update timestamp if user is still logged in
                     if (auth.currentUser && auth.currentUser.uid === currentUserId) {
                         console.log(`Updating lastSeen for ${currentUserId}`);
                         await presenceRef.update({ lastSeen: firebase.firestore.FieldValue.serverTimestamp() });
                     } else {
                         // User logged out unexpectedly between interval checks, clear interval
                         console.warn("User logged out, stopping presence update interval.");
                         clearInterval(presenceUpdateInterval);
                         presenceUpdateInterval = null;
                     }
                } catch (error) {
                    console.error("Error updating presence timestamp:", error);
                    // Optionally stop interval on persistent errors
                    // clearInterval(presenceUpdateInterval);
                    // presenceUpdateInterval = null;
                }
            }, PRESENCE_UPDATE_INTERVAL_MS);

            // Start listening for other online users
            listenForOnlineAdmins();

        } catch (error) {
            console.error("Error registering initial presence:", error);
        }
    }

    async function removePresence(uid) {
        if (!uid) return;
        console.log(`Removing presence for UID: ${uid}`);
        // Stop periodic updates
        if (presenceUpdateInterval) {
            clearInterval(presenceUpdateInterval);
            presenceUpdateInterval = null;
        }
        // Stop listening
        if (onlineUsersListenerUnsubscribe) {
            onlineUsersListenerUnsubscribe();
            onlineUsersListenerUnsubscribe = null;
        }
        // Remove document from Firestore
        try {
            await db.collection(PRESENCE_COLLECTION).doc(uid).delete();
            console.log(`Presence document deleted for ${uid}`);
        } catch (error) {
            console.error("Error removing presence document:", error);
        }
        currentUserId = null; // Clear stored UID
        if(onlineUsersContainer) onlineUsersContainer.innerHTML = '<div class="loading-indicator">Logged out.</div>'; // Clear UI
    }

    function listenForOnlineAdmins() {
        console.log("Starting listener for online admins (including self)..."); // Modified log
        if (onlineUsersListenerUnsubscribe) {
             console.log("Detaching existing online users listener.");
            onlineUsersListenerUnsubscribe(); // Detach previous listener if exists
        }

        // Ensure we have the current user's ID before attaching listener
        if (!currentUserId) {
            console.warn("listenForOnlineAdmins called before currentUserId is set. Aborting.");
            // Optionally display an error message in the UI
            if (onlineUsersContainer) onlineUsersContainer.innerHTML = '<div class="loading-indicator" style="color:orange;">Waiting for user ID...</div>';
            return;
        }


        const query = db.collection(PRESENCE_COLLECTION);
        onlineUsersListenerUnsubscribe = query.onSnapshot(async (snapshot) => {
            console.log(`Presence snapshot received: ${snapshot.size} total users online.`);
            const now = Date.now();
            const onlineAdmins = []; // Will include self now

            // --- Fetch latest authorized admins ---
            let currentAuthorizedUIDs = new Set(); // Default to empty set
            try {
                const authorizedSnapshot = await db.collection('admins').get();
                currentAuthorizedUIDs = new Set(authorizedSnapshot.docs.map(doc => doc.id));
                authorizedAdminUIDs = currentAuthorizedUIDs; // Update global set (optional, but good practice)
                console.log("Fetched authorized admin UIDs:", Array.from(currentAuthorizedUIDs));
            } catch (err) {
                console.error("Error fetching authorized admins within listener:", err);
                // Decide how to handle this - show error? proceed with potentially stale list?
                // For now, let's proceed but log the error. The check below will fail for users if the set is empty.
                if (onlineUsersContainer) onlineUsersContainer.innerHTML = '<div class="loading-indicator" style="color:red;">Error checking admin list. Presence may be incomplete.</div>';
                // return; // Or maybe just return here? Depends on desired behavior on error.
            }
            // --- End fetch ---


            snapshot.forEach(doc => {
                const user = doc.data();
                // Basic validation
                 if (!user || !user.lastSeen || !user.uid || !user.email) {
                     console.warn("Skipping presence doc with missing data:", doc.id, user);
                     return;
                 }

                // --- FILTERING ---
                // 1. Check if authorized (using the freshly fetched list)
                if (!currentAuthorizedUIDs.has(user.uid)) {
                    console.log(`User ${user.email} (UID: ${user.uid}) is online but NOT in the current authorized list. Skipping.`);
                    return; // Skip if not authorized
                }

                // 2. Check if recently active
                let lastSeenTime = null;
                try {
                     lastSeenTime = user.lastSeen.toDate().getTime();
                } catch(e) {
                     console.error(`Error converting lastSeen to Date for user ${user.uid}. Skipping.`, user.lastSeen, e);
                     return; // Skip if timestamp is invalid
                }

                if (now - lastSeenTime < PRESENCE_TIMEOUT_MS) {
                    // User is Authorized and Active - Add to list
                    onlineAdmins.push(user);
                    console.log(`User ${user.email} (UID: ${user.uid}) is AUTHORIZED and ACTIVE. Added to display list.`);
                } else {
                     console.log(`User ${user.email} (UID: ${user.uid}) last seen ${Math.round((now - lastSeenTime)/1000)}s ago. Considered inactive. Skipping.`);
                      // Optional cleanup logic could go here
                }
                 // 3. REMOVED filter for current user:
                 // if (user.uid === currentUserId) return; // <<--- THIS LINE IS REMOVED/COMMENTED OUT
            });

            console.log(`Rendering ${onlineAdmins.length} active authorized admins (including self).`);
            renderOnlineUsers(onlineAdmins); // Render the list (including self if active and authorized)

        }, (error) => {
            console.error("Error in presence listener snapshot:", error);
            if(onlineUsersContainer) onlineUsersContainer.innerHTML = '<div class="loading-indicator" style="color:red;">Error loading presence data.</div>';
             // Attempt to detach listener on error?
             if (onlineUsersListenerUnsubscribe) {
                 onlineUsersListenerUnsubscribe();
                 onlineUsersListenerUnsubscribe = null;
             }
        });
    }

    function renderOnlineUsers(users) {
        if (!onlineUsersContainer) return;
        onlineUsersContainer.innerHTML = ''; // Clear previous state

        if (users.length === 0) {
            onlineUsersContainer.innerHTML = '<div class="loading-indicator">No other admins currently active.</div>';
            return;
        }

        users.sort((a, b) => (a.displayName || a.email).localeCompare(b.displayName || b.email)); // Sort alphabetically

        users.forEach(user => {
            const indicatorDiv = document.createElement('div');
            indicatorDiv.classList.add('user-presence-indicator');

            const circleDiv = document.createElement('div');
            circleDiv.classList.add('user-presence-circle', 'live'); // Add 'live' class for green border
            const initial = user.email ? user.email.charAt(0).toUpperCase() : '?';
            circleDiv.textContent = initial;

            const nameSpan = document.createElement('span');
            nameSpan.classList.add('user-presence-name');
            // Try to get first name from displayName, fallback to email part
            let name = user.displayName ? user.displayName.split(' ')[0] : user.email.split('@')[0];
            // Capitalize first letter
            name = name.charAt(0).toUpperCase() + name.slice(1);
            nameSpan.textContent = name;
            nameSpan.title = user.email; // Show full email on hover

            indicatorDiv.appendChild(circleDiv);
            indicatorDiv.appendChild(nameSpan);
            onlineUsersContainer.appendChild(indicatorDiv);
        });
    }


    // --- Authentication ---
    auth.onAuthStateChanged(async (user) => { // Make handler async
        if (user) {
            console.log("User signed in:", user.email, `(UID: ${user.uid})`);
            loginError.textContent = '';
            authCheckMessage.textContent = ''; // Clear auth message

            // *** CRITICAL: Check Authorization ***
            const isAuthorized = await checkAdminAuthorization(user.uid);

            if (isAuthorized) {
                console.log("Authorization successful. Loading admin panel.");
                loginContainer.classList.add('hidden');
                adminPanel.classList.remove('hidden');
                adminPanel.classList.add('fade-in');
                userInfo.textContent = `Logged in as: ${user.displayName || user.email}`;

                // Start Presence Registration & Load Data
                await registerPresence(user); // Register presence *after* authorization
                loadAdminData(); // Load regular admin data

            } else {
                console.log("Authorization failed. Signing out user.");
                 userInfo.textContent = '';
                // Don't show admin panel, keep login visible with error
                 adminPanel.classList.add('hidden');
                 loginContainer.classList.remove('hidden');
                // Optionally sign the user out automatically if they aren't authorized
                // await auth.signOut(); // Uncomment this line to force sign-out on failed authorization
            }

        } else {
            console.log("User signed out.");
            if (currentUserId) {
                 await removePresence(currentUserId); // Clean up presence using the stored UID
            }
            adminPanel.classList.add('hidden');
            adminPanel.classList.remove('fade-in');
            loginContainer.classList.remove('hidden');
            userInfo.textContent = '';
            loginError.textContent = ''; // Clear login error on logout
            authCheckMessage.textContent = ''; // Clear auth message
            clearAdminUI();
        }
    });


    loginButton.addEventListener('click', () => {
        loginError.textContent = '';
        authCheckMessage.textContent = ''; // Clear messages on new attempt
        console.log("Attempting Google Sign-in...");
        auth.signInWithPopup(googleProvider)
             .then((result) => {
                console.log("Sign-in successful via popup:", result.user?.email);
                // onAuthStateChanged will handle the rest
             })
            .catch((error) => {
                console.error("Login failed:", error.code, error.message, error);
                loginError.textContent = `Login failed: ${error.message}`;
                 if (error.code === 'auth/popup-closed-by-user') {
                     loginError.textContent = 'Login cancelled.';
                 } else if (error.code === 'auth/cancelled-popup-request') {
                      // Ignore, likely second popup blocked
                      loginError.textContent = 'Login popup issue. Please try again.';
                 }
                authCheckMessage.textContent = ''; // Clear auth message on login failure
            });
    });

    logoutButton.addEventListener('click', async () => { // Make async
        console.log("Attempting Sign-out...");
        const uidToClean = currentUserId; // Capture UID before signout might nullify it
        try {
            await auth.signOut();
            console.log("Sign-out successful.");
             // Presence removal is now handled in onAuthStateChanged when user becomes null
             // await removePresence(uidToClean); // No longer strictly needed here, but doesn't hurt
        } catch (error) {
            console.error("Error during sign out:", error);
        }
    });

    function clearAdminUI() {
         console.log("Clearing Admin UI...");
        if (matchesList) matchesList.innerHTML = '';
        if (leaderboardBodyAdmin) leaderboardBodyAdmin.innerHTML = '';
        if (bracketEditor) bracketEditor.innerHTML = '';
        if (saveStatus) saveStatus.textContent = '';
         if (addMatchForm) addMatchForm.classList.add('hidden');
         if (addPlayerForm) addPlayerForm.classList.add('hidden');
         currentBracketData = { rounds: [] };
         currentBracketType = 'pro';
         if (bracketSelect) bracketSelect.value = 'pro';
         if (onlineUsersContainer) onlineUsersContainer.innerHTML = ''; // Clear presence UI

          // Clear intervals and listeners just in case they weren't cleared by removePresence
          if (presenceUpdateInterval) clearInterval(presenceUpdateInterval);
          presenceUpdateInterval = null;
          if (onlineUsersListenerUnsubscribe) onlineUsersListenerUnsubscribe();
          onlineUsersListenerUnsubscribe = null;
          authorizedAdminUIDs.clear();
          currentUserId = null;

          console.log("Admin UI Cleared.");
    }

    // --- Data Loading (Main Admin Sections) ---
    function loadAdminData() {
         console.log("Loading main admin data sections...");
        loadMatchesAdmin();
        loadLeaderboardAdmin();
         if (bracketSelect) {
            currentBracketType = bracketSelect.value;
            loadBracketAdmin(currentBracketType);
         } else {
             console.error("bracketSelect element not found during data load.");
             loadBracketAdmin('pro'); // Load default
         }
    }

    // --- Matches Load/Save/Delete (Keep Existing Logic) ---
    async function loadMatchesAdmin() { /* ... existing code ... */
        if (!matchesList) { console.error("loadMatchesAdmin: matchesList element not found"); return; }
        matchesList.innerHTML = '<div class="loading-indicator">Loading matches...</div>'; // Use class
        console.log("Loading matches from Firestore...");
        try {
            const snapshot = await db.collection('matches').orderBy('date', 'desc').get();
            console.log(`Found ${snapshot.size} matches.`);
            matchesList.innerHTML = '';
            if (snapshot.empty) {
                matchesList.innerHTML = '<p>No matches found.</p>';
                return;
            }
            snapshot.forEach(doc => {
                const match = { id: doc.id, ...doc.data() };
                const dateForInput = match.date?.toDate ? new Date(match.date.toDate().getTime() - match.date.toDate().getTimezoneOffset() * 60000).toISOString().slice(0, 16) : '';
                const matchDiv = document.createElement('div');
                matchDiv.classList.add('match-editor');
                matchDiv.dataset.id = match.id;
                 matchDiv.innerHTML = `
                     <h4>Match ID: ${match.id}</h4>
                     <label>Date:</label><input type="datetime-local" value="${dateForInput}" data-field="date">
                     <label>Type:</label><input type="text" value="${match.type || ''}" data-field="type">
                     <label>Team 1:</label><input type="text" value="${match.team1?.name || ''}" data-field="team1.name">
                     <label>Team 1 Logo:</label><input type="text" value="${match.team1?.logo || ''}" data-field="team1.logo" maxlength="2">
                     <label>Team 2:</label><input type="text" value="${match.team2?.name || ''}" data-field="team2.name">
                     <label>Team 2 Logo:</label><input type="text" value="${match.team2?.logo || ''}" data-field="team2.logo" maxlength="2">
                     <label>Venue:</label><input type="text" value="${match.venue || ''}" data-field="venue">
                     <label>Stream:</label><input type="text" value="${match.streamLink || ''}" data-field="streamLink">
                     <button class="delete-match-button" data-id="${match.id}">Delete Match</button>
                 `;
                matchesList.appendChild(matchDiv);
            });
             attachMatchDeleteListeners(); // Re-attach listeners after rendering

        } catch (error) {
            console.error("Error loading matches:", error);
            matchesList.innerHTML = '<p style="color:red;">Error loading matches.</p>';
        }
     }
    function attachMatchDeleteListeners() { /* ... existing code ... */
        document.querySelectorAll('#matches-list .delete-match-button').forEach(button => {
             // Clone and replace to ensure old listeners are removed
             const newButton = button.cloneNode(true);
             button.parentNode.replaceChild(newButton, button);
             // Add listener to the new button
             newButton.addEventListener('click', async (e) => {
                 const id = e.target.dataset.id;
                 console.log(`Attempting to delete match ID: ${id}`);
                 if (confirm(`Are you sure you want to delete match ${id}?`)) {
                     try {
                         await db.collection('matches').doc(id).delete();
                         console.log(`Match ${id} deleted.`);
                         showSaveStatus('Match deleted successfully!', false);
                         loadMatchesAdmin(); // Reload the list
                     } catch (error) {
                         console.error("Error deleting match:", error);
                         showSaveStatus(`Error deleting match: ${error.message}`, true);
                     }
                 } else { console.log("Deletion cancelled."); }
             });
         });
    }
    addMatchButton.addEventListener('click', () => { /* ... existing code ... */
        console.log("Toggle Add New Match form visibility.");
          if (addMatchForm) addMatchForm.classList.toggle('hidden');
    });
    saveNewMatchButton.addEventListener('click', async () => { /* ... existing code ... */
        console.log("Attempting to save NEW match...");
         const dateValue = document.getElementById('new-match-date').value;
         let matchDateTimestamp = null;
         if (dateValue) {
             try { matchDateTimestamp = firebase.firestore.Timestamp.fromDate(new Date(dateValue)); }
             catch (e) { console.error("Invalid date:", e); showSaveStatus('Error: Invalid Date format.', true); return; }
         } else {
              showSaveStatus('Error: Match Date & Time is required.', true); return; // Make date required
         }
         const newMatchData = {
             date: matchDateTimestamp,
             type: document.getElementById('new-match-type').value.trim(),
             team1: { name: document.getElementById('new-match-team1-name').value.trim(), logo: document.getElementById('new-match-team1-logo').value.trim().toUpperCase() },
             team2: { name: document.getElementById('new-match-team2-name').value.trim(), logo: document.getElementById('new-match-team2-logo').value.trim().toUpperCase() },
             venue: document.getElementById('new-match-venue').value.trim(),
             streamLink: document.getElementById('new-match-stream').value.trim()
         };
         // Basic validation
         if (!newMatchData.type || !newMatchData.team1.name || !newMatchData.team2.name) {
             showSaveStatus('Error: Type, Team 1 Name, and Team 2 Name are required.', true); return;
         }
         console.log("New match validated:", newMatchData);
         showSaveStatus('Saving new match...', false);
         try {
             const docRef = await db.collection('matches').add(newMatchData);
             console.log("New match added ID:", docRef.id); showSaveStatus('New match added!', false);
             addMatchForm.classList.add('hidden');
             // Reset form more carefully
             document.getElementById('new-match-date').value = '';
             document.getElementById('new-match-type').value = '';
             document.getElementById('new-match-team1-name').value = '';
             document.getElementById('new-match-team1-logo').value = '';
             document.getElementById('new-match-team2-name').value = '';
             document.getElementById('new-match-team2-logo').value = '';
             document.getElementById('new-match-venue').value = '';
             document.getElementById('new-match-stream').value = 'https://www.twitch.tv/poxelcompetitive/'; // Reset stream link
             loadMatchesAdmin(); // Reload list
         } catch (error) {
             console.error("Error adding match:", error);
             showSaveStatus(`Error adding match: ${error.message}`, true);
         }
    });
    saveMatchesChangesButton.addEventListener('click', async () => { /* ... existing code ... */
        console.log("Attempting to save ALL match changes...");
         const updates = [];
         let errorsFound = false;
         document.querySelectorAll('#matches-list .match-editor').forEach(editor => {
             const id = editor.dataset.id;
             if (!id) return;

             const matchData = { team1: {}, team2: {} };
             let hasError = false;

             // Date Validation
             const dateInput = editor.querySelector('input[data-field="date"]');
             if (dateInput) {
                 const dateValue = dateInput.value;
                 if (dateValue) {
                     try {
                         matchData.date = firebase.firestore.Timestamp.fromDate(new Date(dateValue));
                     } catch (e) {
                         console.error(`Invalid date format for match ${id}: ${dateValue}`, e);
                         showSaveStatus(`Error: Invalid date for match ${id}. Fix and save again.`, true);
                         hasError = true;
                         errorsFound = true;
                     }
                 } else {
                     // If date is allowed to be null, set it to null. If required, mark as error.
                      console.warn(`Date missing for match ${id}. Setting to null.`);
                      // showSaveStatus(`Error: Date is required for match ${id}.`, true); // Uncomment if date is mandatory
                      // hasError = true;
                      // errorsFound = true;
                      matchData.date = null;
                 }
             } else {
                 console.warn(`Date input not found for match ${id}`);
             }


             // Process other fields only if date is valid (or not required/handled)
             if (!hasError) {
                 editor.querySelectorAll('input[type="text"], input[type="number"]').forEach(input => {
                     // Skip date field as it's already handled
                     if (input.dataset.field === 'date') return;

                     const fieldPath = input.dataset.field;
                     let value = input.value.trim();
                     if (input.type === "text" && input.maxLength === 2) { // Assume logo fields
                         value = value.toUpperCase();
                     }

                     if (fieldPath?.includes('.')) {
                         const parts = fieldPath.split('.');
                         if (parts.length === 2) {
                             if (!matchData[parts[0]]) matchData[parts[0]] = {}; // Ensure nested object exists
                             matchData[parts[0]][parts[1]] = value;
                         }
                     } else if (fieldPath) {
                         matchData[fieldPath] = value;
                     }
                 });
                 // Add validation for required fields if necessary
                 if (!matchData.type || !matchData.team1?.name || !matchData.team2?.name) {
                     console.error(`Missing required field(s) for match ${id}`);
                      showSaveStatus(`Error: Missing Type or Team Names for match ${id}.`, true);
                      hasError = true;
                      errorsFound = true;
                 }
             }

             if (!hasError) {
                 console.log(`Queueing update for Match ID ${id}:`, matchData);
                 updates.push({ id: id, data: matchData });
             }
         });

         if (errorsFound) {
             showSaveStatus('Errors found. Please fix them before saving all changes.', true);
             console.log("Save aborted due to validation errors.");
             return;
         }

         if (updates.length === 0) {
             showSaveStatus('No changes detected or queued for saving.', false);
             return;
         }

         console.log(`Proceeding with batch update for ${updates.length} matches.`);
         showSaveStatus(`Saving ${updates.length} match changes...`, false);
         const batch = db.batch();
         updates.forEach(update => {
             const docRef = db.collection('matches').doc(update.id);
             batch.update(docRef, update.data);
         });

         try {
             await batch.commit();
             console.log("Batch update successful.");
             showSaveStatus(`${updates.length} match(es) updated successfully!`, false);
             loadMatchesAdmin(); // Refresh list after successful save
         } catch (error) {
             console.error("Error committing batch update for matches:", error);
             showSaveStatus(`Error saving match changes: ${error.message}`, true);
         }
     });

    // --- Leaderboard Load/Save/Delete (Keep Existing Logic) ---
    async function loadLeaderboardAdmin() { /* ... existing code ... */
        if (!leaderboardBodyAdmin) { console.error("loadLeaderboardAdmin: leaderboardBodyAdmin element not found"); return; }
        leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8" class="loading-indicator">Loading leaderboard...</td></tr>'; // Use class
         console.log("Loading leaderboard from Firestore...");
         try {
             const snapshot = await db.collection('leaderboard').orderBy('points', 'desc').get();
             console.log(`Found ${snapshot.size} players.`);
             leaderboardBodyAdmin.innerHTML = '';
             let rank = 1;
             if (snapshot.empty) {
                 leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8">No players found.</td></tr>';
                 return;
             }
             snapshot.forEach(doc => {
                 const player = { id: doc.id, ...doc.data() };
                 const row = document.createElement('tr');
                 row.dataset.id = player.id;
                  // Ensure values are set, default to 0 for numbers if null/undefined
                  const matches = player.matches ?? 0;
                  const wins = player.wins ?? 0;
                  const losses = player.losses ?? 0;
                  const points = player.points ?? 0;
                  row.innerHTML = `
                      <td>${rank++}</td>
                      <td><input type="text" value="${player.name || ''}" data-field="name" required></td>
                      <td><input type="text" value="${player.avatar || ''}" data-field="avatar" maxlength="2"></td>
                      <td><input type="number" value="${matches}" data-field="matches" min="0"></td>
                      <td><input type="number" value="${wins}" data-field="wins" min="0"></td>
                      <td><input type="number" value="${losses}" data-field="losses" min="0"></td>
                      <td><input type="number" value="${points}" data-field="points"></td>
                       <td><button class="delete-player-button" data-id="${player.id}">Delete</button></td>
                  `;
                 leaderboardBodyAdmin.appendChild(row);
             });
             attachPlayerDeleteListeners(); // Re-attach listeners

         } catch (error) {
             console.error("Error loading leaderboard:", error);
             leaderboardBodyAdmin.innerHTML = '<tr><td colspan="8" style="color:red;">Error loading leaderboard.</td></tr>';
         }
     }
    function attachPlayerDeleteListeners() { /* ... existing code ... */
        console.log("Attaching player delete listeners...");
         const buttons = document.querySelectorAll('#leaderboard-body-admin .delete-player-button');
          console.log(`Found ${buttons.length} delete player buttons.`);

         // Remove old listeners by replacing nodes
          buttons.forEach(button => {
             const newButton = button.cloneNode(true);
             button.parentNode.replaceChild(newButton, button);

             // Add listener to the new button
             newButton.addEventListener('click', async (e) => {
                 const id = e.target.dataset.id;
                 if (!id) { console.error("Delete Error: No ID found on button dataset."); return; }

                 // Try to get player name for confirmation message
                 const row = e.target.closest('tr');
                 const nameInput = row ? row.querySelector('input[data-field="name"]') : null;
                 const playerName = nameInput ? nameInput.value : `Player ID: ${id}`;

                 console.log(`Attempting to delete player: ${playerName} (ID: ${id})`);
                 if (confirm(`Are you sure you want to delete player "${playerName}"? This action cannot be undone.`)) {
                     try {
                         await db.collection('leaderboard').doc(id).delete();
                          console.log(`Player ${id} deleted from Firestore.`);
                         showSaveStatus('Player deleted successfully!', false);
                         loadLeaderboardAdmin(); // Refresh the leaderboard
                     } catch (error) {
                         console.error(`Error deleting player ${id} from Firestore:`, error);
                         showSaveStatus(`Error deleting player: ${error.message}`, true);
                     }
                 } else {
                     console.log("Player deletion cancelled.");
                 }
             });
         });
     }
    addPlayerButton.addEventListener('click', () => { /* ... existing code ... */
        console.log("Toggle Add New Player form.");
          if (addPlayerForm) addPlayerForm.classList.toggle('hidden');
    });
    saveNewPlayerButton.addEventListener('click', async () => { /* ... existing code ... */
        console.log("Attempting to save new player...");
         const nameInput = document.getElementById('new-player-name');
         const avatarInput = document.getElementById('new-player-avatar');
         const matchesInput = document.getElementById('new-player-matches');
         const winsInput = document.getElementById('new-player-wins');
         const lossesInput = document.getElementById('new-player-losses');
         const pointsInput = document.getElementById('new-player-points');

         if (!nameInput || !avatarInput || !matchesInput || !winsInput || !lossesInput || !pointsInput) {
             console.error("Save New Player Error: Input element(s) missing.");
             showSaveStatus('Error: Could not find all player form fields.', true);
             return;
         }

         const name = nameInput.value.trim();
         const avatar = avatarInput.value.trim().toUpperCase();
         const matches = parseInt(matchesInput.value) || 0;
         const wins = parseInt(winsInput.value) || 0;
         const losses = parseInt(lossesInput.value) || 0;
         const points = parseInt(pointsInput.value) || 0;

         // Validation
         if (!name) {
             console.warn("Validation fail: Player Name is required.");
             showSaveStatus('Error: Player Name is required.', true);
             nameInput.focus(); // Focus the name input
             return;
         }
         if (isNaN(matches) || isNaN(wins) || isNaN(losses) || isNaN(points)) {
              console.warn("Validation fail: Non-numeric value entered for stats.");
              showSaveStatus('Error: Matches, Wins, Losses, and Points must be numbers.', true);
              return;
         }

         const newPlayerData = {
             name: name,
             avatar: avatar,
             matches: Math.max(0, matches), // Ensure non-negative
             wins: Math.max(0, wins),
             losses: Math.max(0, losses),
             points: points // Points can be negative? If not, add Math.max(0, points)
         };

         console.log("New player validated:", newPlayerData);
         showSaveStatus('Saving new player...', false);

         try {
             const docRef = await db.collection('leaderboard').add(newPlayerData);
             console.log("New player added ID:", docRef.id);
             showSaveStatus('New player added successfully!', false);

             // Hide form and reset fields
             addPlayerForm.classList.add('hidden');
             nameInput.value = '';
             avatarInput.value = '';
             matchesInput.value = '0';
             winsInput.value = '0';
             lossesInput.value = '0';
             pointsInput.value = '0';

             loadLeaderboardAdmin(); // Refresh the leaderboard
         } catch (error) {
             console.error("Error adding player:", error);
             showSaveStatus(`Error adding player: ${error.message}`, true);
         }
     });
    saveLeaderboardChangesButton.addEventListener('click', async () => { /* ... existing code ... */
        console.log("Attempting to save all leaderboard changes...");
        const updates = [];
        let errorsFound = false;

        document.querySelectorAll('#leaderboard-body-admin tr').forEach(row => {
            const id = row.dataset.id;
            if (!id) return; // Skip if row doesn't have an ID (e.g., header or add row)

            const playerData = {};
            let hasRowError = false;

            row.querySelectorAll('input').forEach(input => {
                const field = input.dataset.field;
                if (!field) return; // Skip inputs without data-field attribute

                let value = input.value.trim();

                // Validate and parse based on type
                if (input.type === 'number') {
                    const parsedValue = parseInt(value);
                    if (isNaN(parsedValue)) {
                        console.error(`Invalid number format for player ${id}, field ${field}: "${value}"`);
                        showSaveStatus(`Error: Invalid number for ${field} in row for ID ${id}.`, true);
                        hasRowError = true;
                        errorsFound = true;
                        value = 0; // Default to 0 on error? Or skip update? Let's skip for now.
                    } else {
                         // Ensure non-negative for stats, allow any for points
                         if (field === 'matches' || field === 'wins' || field === 'losses') {
                             value = Math.max(0, parsedValue);
                         } else {
                             value = parsedValue;
                         }
                    }
                } else if (input.type === 'text') {
                    if (field === 'name' && !value) { // Name is required
                        console.error(`Player Name cannot be empty for ID ${id}.`);
                         showSaveStatus(`Error: Player Name is required for ID ${id}.`, true);
                         hasRowError = true;
                         errorsFound = true;
                    }
                    if (field === 'avatar') {
                        value = value.toUpperCase();
                    }
                }
                 // Only assign if no error occurred for this input type
                 if (!errorsFound || input.type !== 'number' || !isNaN(parseInt(input.value))) {
                     playerData[field] = value;
                 }

            });

            // Add to updates only if the row has an ID and no errors occurred for this row
            if (id && !hasRowError) {
                console.log(`Queueing update for Player ID ${id}:`, playerData);
                updates.push({ id: id, data: playerData });
            }
        });

        if (errorsFound) {
             showSaveStatus('Errors found in leaderboard data. Please fix them before saving.', true);
            console.log("Save aborted due to validation errors in leaderboard.");
            return;
        }

        if (updates.length === 0) {
            console.log("No valid leaderboard changes detected to save.");
            showSaveStatus('No changes detected or ready to save.', false);
            return;
        }

        console.log(`Proceeding with batch update for ${updates.length} players.`);
        showSaveStatus(`Saving ${updates.length} player changes...`, false);
        const batch = db.batch();
        updates.forEach(update => {
            const docRef = db.collection('leaderboard').doc(update.id);
            batch.update(docRef, update.data);
        });

        try {
            await batch.commit();
            console.log("Leaderboard batch update successful.");
            showSaveStatus(`${updates.length} player(s) updated successfully!`, false);
            loadLeaderboardAdmin(); // Refresh leaderboard after successful save
        } catch (error) {
            console.error("Error committing batch update for leaderboard:", error);
            showSaveStatus(`Error saving leaderboard changes: ${error.message}`, true);
        }
    });

    // --- Bracket Load / Render / Save (Keep Existing Logic - including FIX) ---
    async function loadBracketAdmin(bracketType = 'pro') { /* ... existing code ... */
        if (!bracketEditor || !bracketLoadingIndicator) {
            console.error("loadBracketAdmin: necessary bracket elements not found");
            return;
        }
        currentBracketType = bracketType; // Update global state
        bracketEditor.dataset.type = bracketType; // Update UI element data attribute
        bracketLoadingIndicator.classList.remove('hidden');
        bracketLoadingIndicator.textContent = `Loading ${bracketType} bracket...`;
        bracketEditor.innerHTML = ''; // Clear previous content while loading

        console.log(`--- Loading bracket: ${bracketType} ---`);
        try {
            const docRef = db.collection('brackets').doc(bracketType);
            const docSnap = await docRef.get();

            // Use docSnap.exists property
            console.log(`[${bracketType}] Document snapshot received. Exists: ${docSnap.exists}`);

            if (docSnap.exists) {
                currentBracketData = docSnap.data();
                // Ensure rounds and matches arrays exist & handle potential nulls/undefined from Firestore
                if (!currentBracketData || typeof currentBracketData !== 'object') currentBracketData = {}; // Ensure it's an object
                if (!Array.isArray(currentBracketData.rounds)) currentBracketData.rounds = []; // Ensure rounds is an array

                 currentBracketData.rounds.forEach(round => {
                      if (!round || typeof round !== 'object') round = { name: 'Unnamed Round', matches: [] }; // Fix invalid round objects
                     if (!Array.isArray(round.matches)) round.matches = []; // Ensure matches is an array in each round
                      round.matches.forEach(match => {
                         if (!match || typeof match !== 'object') match = {}; // Fix invalid match objects
                         if (!match.team1 || typeof match.team1 !== 'object') match.team1 = { name: '', score: null };
                         if (!match.team2 || typeof match.team2 !== 'object') match.team2 = { name: '', score: null };
                         // Ensure score is number or null
                         match.team1.score = (match.team1.score === undefined || match.team1.score === '') ? null : Number(match.team1.score);
                         match.team2.score = (match.team2.score === undefined || match.team2.score === '') ? null : Number(match.team2.score);
                         match.completed = !!match.completed; // Ensure boolean
                      });
                 });
                console.log(`[${bracketType}] Loaded and sanitized bracket data into state:`, JSON.parse(JSON.stringify(currentBracketData)));
            } else {
                console.log(`[${bracketType}] No bracket data found. Initializing empty state.`);
                currentBracketData = { rounds: [] }; // Initialize with empty structure
            }
            renderBracketEditor(); // Render the UI based on the state
            console.log(`--- Finished loading bracket: ${bracketType} successfully ---`);
        } catch (error) {
            console.error(`--- ERROR loading ${bracketType} bracket: ---`, error);
            bracketEditor.innerHTML = `<p style="color:red;">Error loading ${bracketType} bracket: ${error.message}. Check console.</p>`;
             currentBracketData = { rounds: [] }; // Reset state on error
        } finally {
            bracketLoadingIndicator.classList.add('hidden');
        }
     }
    function renderBracketEditor() { /* ... existing code ... */
        console.log(`Rendering bracket editor from state for ${currentBracketType}. Data:`, JSON.parse(JSON.stringify(currentBracketData)));
         if (!bracketEditor) { console.error("renderBracketEditor: bracketEditor element not found!"); return; }

         bracketEditor.innerHTML = ''; // Clear existing content
         bracketEditor.dataset.type = currentBracketType;

         const rounds = currentBracketData.rounds || [];

         if (rounds.length === 0) {
             console.log("No rounds in state. Displaying 'No rounds' message.");
             const placeholder = document.createElement('p');
             placeholder.textContent = 'No rounds in this bracket yet. Use "Add New Round" below.';
             placeholder.style.padding = '20px'; // Add some padding
             placeholder.style.textAlign = 'center';
             placeholder.style.color = 'var(--text-secondary)';
             bracketEditor.appendChild(placeholder);
         } else {
             console.log(`Rendering ${rounds.length} rounds from state...`);
             rounds.forEach((round, roundIndex) => {
                 const roundColumnDiv = document.createElement('div');
                 roundColumnDiv.classList.add('bracket-round-column');
                 roundColumnDiv.dataset.roundIndex = roundIndex;

                  // Sanitize round name before display
                  const roundName = round && typeof round === 'object' && round.name ? round.name : `Round ${roundIndex + 1}`;

                 roundColumnDiv.innerHTML = `
                     <h4>
                         <input type="text" value="${roundName}" class="round-name" placeholder="Round Name" data-round-index="${roundIndex}" data-field="name" title="Round Name">
                         <button class="delete-round-button" data-round-index="${roundIndex}" title="Delete this entire round">Delete Round</button>
                     </h4>
                     <div class="matches-in-round">
                         <!-- Matches will be added here -->
                     </div>
                     <button class="add-match-to-round-button" data-round-index="${roundIndex}" title="Add a new match to this round">Add Match</button>
                 `;

                 const matchesContainer = roundColumnDiv.querySelector('.matches-in-round');
                 // Ensure round and round.matches exist and are arrays before accessing
                 const matches = round && Array.isArray(round.matches) ? round.matches : [];

                 if (matches.length > 0) {
                      console.log(`Rendering ${matches.length} matches for round ${roundIndex + 1}...`);
                     matches.forEach((match, matchIndex) => {
                         // Pass the potentially sanitized match object
                         const matchDiv = renderBracketMatchEditor(match || {}, roundIndex, matchIndex);
                         if (matchDiv && matchesContainer) {
                             matchesContainer.appendChild(matchDiv);
                         } else {
                             console.error("Error: Couldn't append matchDiv, container or div is null", matchDiv, matchesContainer);
                         }
                     });
                 } else {
                      console.log(`No matches for round ${roundIndex + 1}.`);
                     const p = document.createElement('p');
                     p.textContent = 'No matches yet in this round.';
                     p.style.textAlign = 'center';
                     p.style.fontSize = '0.9em';
                     p.style.color = 'var(--text-secondary)';
                     matchesContainer.appendChild(p);
                 }
                 bracketEditor.appendChild(roundColumnDiv);
             });
         }

         // Attach event listeners after rendering
         console.log("Attaching bracket editor listeners after rendering.");
         attachBracketEditorListeners(); // Ensure this function is called to re-attach listeners
     }
    function renderBracketMatchEditor(match, roundIndex, matchIndex) { /* ... existing code ... */
        // console.log(`Rendering match editor for R${roundIndex+1} M${matchIndex+1} from data:`, match); // Can be noisy
        const matchDiv = document.createElement('div');
        matchDiv.classList.add('bracket-match-editor');
        matchDiv.dataset.roundIndex = roundIndex;
        matchDiv.dataset.matchIndex = matchIndex;

        // Use default empty values if match or its properties are null/undefined
        const team1Name = match?.team1?.name || '';
        const team1Score = (match?.team1?.score === null || match?.team1?.score === undefined) ? '' : match.team1.score; // Display empty string for null/undefined score
        const team2Name = match?.team2?.name || '';
        const team2Score = (match?.team2?.score === null || match?.team2?.score === undefined) ? '' : match.team2.score;
        const winnerName = match?.winnerName || ''; // winnerName might be manually entered
        const completed = match?.completed || false;

        matchDiv.innerHTML = `
            <h5>Match ${matchIndex + 1}
            <button class="delete-match-from-round-button" data-round-index="${roundIndex}" data-match-index="${matchIndex}" title="Delete this match">Delete</button>
            </h5>
            <label>Team 1 Name:</label> <input type="text" value="${team1Name}" class="bracket-team1-name" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="team1.name">
            <label>Team 1 Score:</label> <input type="number" value="${team1Score}" class="bracket-team1-score" placeholder="-" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="team1.score" min="0">
            <label>Team 2 Name:</label> <input type="text" value="${team2Name}" class="bracket-team2-name" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="team2.name">
            <label>Team 2 Score:</label> <input type="number" value="${team2Score}" class="bracket-team2-score" placeholder="-" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="team2.score" min="0">
            <label>Winner (Exact name or blank):</label> <input type="text" value="${winnerName}" class="bracket-winner-name" placeholder="Enter winning team name" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="winnerName">
            <label class="checkbox-label">
                <input type="checkbox" ${completed ? 'checked' : ''} class="bracket-match-completed" data-round-index="${roundIndex}" data-match-index="${matchIndex}" data-field="completed"> Completed
            </label>
        `;
        return matchDiv;
     }
    function attachBracketEditorListeners() { /* ... existing code ... */
        console.log("Attaching/Re-attaching listeners for bracket editor actions.");
        if (!bracketEditor) { console.error("Cannot attach listeners: bracketEditor not found."); return; }

        // Use event delegation on the main editor container for dynamic elements
        bracketEditor.removeEventListener('click', handleBracketButtonClick); // Remove old listener first
        bracketEditor.addEventListener('click', handleBracketButtonClick);

        // Use event delegation for input changes as well
        bracketEditor.removeEventListener('input', handleBracketInput);
        bracketEditor.removeEventListener('change', handleBracketInput); // For checkboxes
        bracketEditor.addEventListener('input', handleBracketInput);
        bracketEditor.addEventListener('change', handleBracketInput);

        // --- Direct listeners for static controls OUTSIDE the main editor ---
        if (addRoundButton) {
             addRoundButton.removeEventListener('click', handleAddRoundClick); // Remove old before adding new
             addRoundButton.addEventListener('click', handleAddRoundClick);
        } else { console.error("Add Round Button not found."); }

        if (saveBracketChangesButton) {
             saveBracketChangesButton.removeEventListener('click', handleSaveBracketClick); // Remove old before adding new
             saveBracketChangesButton.addEventListener('click', handleSaveBracketClick);
        } else { console.error("Save Bracket Button not found."); }

        if (bracketSelect) {
             bracketSelect.removeEventListener('change', handleBracketSelectChange); // Remove old before adding new
             bracketSelect.addEventListener('change', handleBracketSelectChange);
        } else { console.error("Bracket Select dropdown not found."); }
        console.log("Bracket editor listeners attached.");
    }
    function handleBracketSelectChange(e) { /* ... existing code ... */
        const newType = e.target.value;
        console.log(`Bracket selection changed to: ${newType}`);
        // !! Consider adding a check here for unsaved changes before loading !!
        // if (hasUnsavedBracketChanges()) { // You'd need a flag or way to check this
        //     if (!confirm("You have unsaved changes in the current bracket. Discard changes and load the new bracket?")) {
        //         e.target.value = currentBracketType; // Revert selection
        //         return;
        //     }
        // }
        loadBracketAdmin(newType);
     }
    function handleAddRoundClick() { /* ... existing code ... */
        console.log("Add Round button clicked. Adding to state.");
        if (!currentBracketData || !Array.isArray(currentBracketData.rounds)) {
            console.warn("currentBracketData.rounds is not an array. Initializing.");
            currentBracketData = { rounds: [] }; // Initialize if state is broken
        }
        // Add a new round object to the state
        currentBracketData.rounds.push({ name: `Round ${currentBracketData.rounds.length + 1}`, matches: [] });
        console.log("Round added to state. Re-rendering editor.");
        renderBracketEditor(); // Re-render UI from state
     }
    async function handleSaveBracketClick() { /* ... existing code ... */
        console.log(`Attempting to save bracket changes for: ${currentBracketType}. State data before final prep:`, JSON.parse(JSON.stringify(currentBracketData)));
        if (!currentBracketType) { console.error("Save Bracket Error: No bracket type specified."); showSaveStatus('Error: Cannot determine which bracket to save.', true); return; }
        if (!currentBracketData || !Array.isArray(currentBracketData.rounds)) {
            console.error("Save Bracket Error: Bracket data is invalid or missing.");
            showSaveStatus('Error: Bracket data structure is invalid. Cannot save.', true);
            return;
        }

        // --- Validation and Final Data Preparation from State ---
        // Create a deep clone to modify for saving without affecting the live state until success
        let dataToSave;
        try {
             dataToSave = JSON.parse(JSON.stringify(currentBracketData));
        } catch (e) {
             console.error("Save Bracket Error: Failed to clone bracket data.", e);
             showSaveStatus('Error: Failed to prepare bracket data for saving.', true);
             return;
        }

        let validationError = false;

        dataToSave.rounds.forEach((round, roundIndex) => {
             if (!round || typeof round !== 'object') { // Basic check for valid round object
                 console.error(`Validation Error: Invalid round object at index ${roundIndex}.`);
                 showSaveStatus(`Error: Invalid data found in Round ${roundIndex + 1}. Save aborted.`, true);
                 validationError = true;
                 return; // Skip this round
             }

            // Clean up round name
            round.name = round.name ? round.name.trim() : `Round ${roundIndex + 1}`;
            if (!Array.isArray(round.matches)) {
                 console.warn(`Round ${roundIndex + 1} ('${round.name}') has invalid matches array. Setting to empty.`);
                 round.matches = [];
            }

            round.matches.forEach((match, matchIndex) => {
                 if (!match || typeof match !== 'object') { // Basic check for valid match object
                     console.error(`Validation Error: Invalid match object at R${roundIndex+1} M${matchIndex+1}.`);
                     showSaveStatus(`Error: Invalid data found in match ${matchIndex + 1}, Round ${roundIndex + 1}. Save aborted.`, true);
                     validationError = true;
                     return; // Skip this match
                 }

                 // Ensure team objects exist
                 if (!match.team1 || typeof match.team1 !== 'object') match.team1 = {};
                 if (!match.team2 || typeof match.team2 !== 'object') match.team2 = {};

                 // Trim names
                 match.team1.name = match.team1.name ? match.team1.name.trim() : '';
                 match.team2.name = match.team2.name ? match.team2.name.trim() : '';

                 // Ensure scores are numbers or null
                 match.team1.score = (match.team1.score === '' || match.team1.score === undefined || match.team1.score === null) ? null : Number(match.team1.score);
                 match.team2.score = (match.team2.score === '' || match.team2.score === undefined || match.team2.score === null) ? null : Number(match.team2.score);

                 if (isNaN(match.team1.score) && match.team1.score !== null) {
                     console.error(`Validation Error: Invalid Team 1 score for R${roundIndex+1} M${matchIndex+1}: "${match.team1.score}"`);
                     showSaveStatus(`Error: Invalid score T1 in R${roundIndex+1} M${matchIndex+1}. Save aborted.`, true);
                     validationError = true;
                 }
                  if (isNaN(match.team2.score) && match.team2.score !== null) {
                     console.error(`Validation Error: Invalid Team 2 score for R${roundIndex+1} M${matchIndex+1}: "${match.team2.score}"`);
                     showSaveStatus(`Error: Invalid score T2 in R${roundIndex+1} M${matchIndex+1}. Save aborted.`, true);
                     validationError = true;
                 }

                 // Ensure 'completed' is a boolean
                 match.completed = !!match.completed;
                 // Trim winnerName
                 match.winnerName = match.winnerName ? match.winnerName.trim() : '';

                // Determine 'winner' field based on completed status and winnerName input
                match.winner = null; // Default to no winner
                if (match.completed && match.winnerName) {
                     const winnerNameLower = match.winnerName.toLowerCase();
                     const team1NameLower = match.team1.name?.toLowerCase();
                     const team2NameLower = match.team2.name?.toLowerCase();

                    if (team1NameLower && winnerNameLower === team1NameLower) {
                        match.winner = match.team1.name; // Use the exact (trimmed) name from team1
                    } else if (team2NameLower && winnerNameLower === team2NameLower) {
                         match.winner = match.team2.name; // Use the exact (trimmed) name from team2
                    } else {
                         console.warn(`Winner name "${match.winnerName}" in R${roundIndex+1} M${matchIndex+1} does not exactly match either team name ("${match.team1.name}" or "${match.team2.name}"). 'winner' field will be null.`);
                         // Keep winnerName as entered by user, but winner field (used potentially for auto-advancing) remains null
                    }
                } else if (match.completed && !match.winnerName) {
                     console.warn(`Match R${roundIndex+1} M${matchIndex+1} is marked completed, but no winner name was entered. 'winner' field will be null.`);
                }
            });
        });

        if (validationError) {
            console.error("Save aborted due to validation errors detected during final preparation.");
            return; // Stop before attempting to save invalid data
        }

        // --- Save to Firestore ---
        console.log(`Saving validated and prepared bracket data for ${currentBracketType}:`, JSON.parse(JSON.stringify(dataToSave)));
        showSaveStatus(`Saving ${currentBracketType} bracket changes...`, false);
        try {
            // Use .set() to completely overwrite the document with the new structure
            // This ensures deleted rounds/matches are removed from Firestore.
            await db.collection('brackets').doc(currentBracketType).set(dataToSave);
            console.log("Bracket saved successfully to Firestore.");
            showSaveStatus(`${currentBracketType} bracket saved successfully!`, false);
            // Optional: Mark changes as saved if tracking unsaved state
            // hasUnsavedBracketChanges = false;
        }
        catch (error) {
            console.error(`Error saving ${currentBracketType} bracket to Firestore:`, error);
            showSaveStatus(`Error saving bracket: ${error.message}`, true);
        }
     }
    function handleBracketButtonClick(event) { /* ... existing code ... */
        const target = event.target;
        // console.log("Click detected inside bracket editor. Target:", target); // Debugging clicks

        // Check for specific button classes using classList.contains
        if (target.classList.contains('delete-round-button') && target.dataset.roundIndex !== undefined) {
            const roundIndex = parseInt(target.dataset.roundIndex);
             console.log("Delegated click: Delete Round button handled for index:", roundIndex);
            if (!isNaN(roundIndex)) {
                 deleteBracketRoundFromState(roundIndex);
            } else { console.error("Invalid round index for delete:", target.dataset.roundIndex); }
        } else if (target.classList.contains('add-match-to-round-button') && target.dataset.roundIndex !== undefined) {
            const roundIndex = parseInt(target.dataset.roundIndex);
             console.log("Delegated click: Add Match button handled for round index:", roundIndex);
             if (!isNaN(roundIndex)) {
                 addBracketMatchToState(roundIndex);
             } else { console.error("Invalid round index for add match:", target.dataset.roundIndex); }
        } else if (target.classList.contains('delete-match-from-round-button') && target.dataset.roundIndex !== undefined && target.dataset.matchIndex !== undefined) {
            const roundIndex = parseInt(target.dataset.roundIndex);
            const matchIndex = parseInt(target.dataset.matchIndex);
            console.log("Delegated click: Delete Match button handled for R:", roundIndex, " M:", matchIndex);
            if (!isNaN(roundIndex) && !isNaN(matchIndex)) {
                 deleteBracketMatchFromState(roundIndex, matchIndex);
            } else { console.error("Invalid indices for delete match:", target.dataset.roundIndex, target.dataset.matchIndex); }
        } else {
             // console.log("Click was not on a recognized button or lacked necessary data attributes."); // Debugging unmatched clicks
        }
     }
    function handleBracketInput(event) { /* ... existing code ... */
        const target = event.target;
         // Only process if it's an input or checkbox within the bracket editor context
        if (!target || !(target.tagName === 'INPUT' || target.tagName === 'TEXTAREA')) return; // Basic check
        if (!target.closest('.bracket-round-column')) return; // Ensure it's within a bracket column

        const roundIndexStr = target.dataset.roundIndex;
        const matchIndexStr = target.dataset.matchIndex;
        const field = target.dataset.field;

        // console.log(`Input event: Target type=${target.type}, field=${field}, round=${roundIndexStr}, match=${matchIndexStr}, value=${target.value || target.checked}`); // Debug

        if (roundIndexStr === undefined || field === undefined) {
             // console.log("Input ignored: Missing roundIndex or field data attribute.");
             return; // Ignore inputs lacking necessary info
        }

        const roundIndex = parseInt(roundIndexStr);
        const matchIndex = (matchIndexStr !== undefined) ? parseInt(matchIndexStr) : null; // matchIndex can be null for round name

        if (isNaN(roundIndex) || (matchIndexStr !== undefined && isNaN(matchIndex))) {
             console.error("Invalid index detected in input handler:", roundIndexStr, matchIndexStr);
             return; // Invalid index parsing
        }

        // --- Update State ---
        try {
             if (!currentBracketData || !Array.isArray(currentBracketData.rounds) || !currentBracketData.rounds[roundIndex]) {
                 console.warn(`State Error: Round ${roundIndex} not found in currentBracketData.rounds`);
                 return;
             }
             const round = currentBracketData.rounds[roundIndex];

             if (matchIndex === null) { // --- It's a round-level input (e.g., round name) ---
                 if (field === 'name') {
                      console.log(`Updating round ${roundIndex} name to: ${target.value}`);
                      round.name = target.value.trim();
                 } else {
                      console.warn(`Unhandled round-level field: ${field}`);
                 }
             } else { // --- It's a match-level input ---
                 if (!round.matches || !Array.isArray(round.matches) || !round.matches[matchIndex]) {
                     console.warn(`State Error: Match ${matchIndex} not found in round ${roundIndex}`);
                     return;
                 }
                 const match = round.matches[matchIndex];

                 let value;
                 if (target.type === 'checkbox') {
                     value = target.checked;
                 } else if (target.type === 'number') {
                      // Store empty number input as null, otherwise parse as number
                      value = target.value === '' ? null : parseFloat(target.value); // Use parseFloat for potential decimal scores? Or stick to parseInt? Let's use parseInt assuming integer scores.
                      value = target.value === '' ? null : parseInt(target.value);
                       if (isNaN(value) && target.value !== '') { // Check if parsing failed but input wasn't empty
                           console.warn(`Could not parse number for field ${field}: ${target.value}. Storing as null.`);
                           value = null; // Store as null if parsing fails
                       }
                 } else {
                     value = target.value; // For text inputs, keep original value (trimming happens on save)
                 }

                 console.log(`Updating state: R${roundIndex} M${matchIndex} field "${field}" to:`, value);

                 // Handle nested fields (like team1.name, team1.score)
                 if (field.includes('.')) {
                     const parts = field.split('.');
                     if (parts.length === 2) {
                          // Ensure the parent object (e.g., team1) exists
                          if (!match[parts[0]] || typeof match[parts[0]] !== 'object') {
                              match[parts[0]] = {};
                          }
                          match[parts[0]][parts[1]] = value;
                     } else {
                          console.warn(`Unhandled complex field path in input handler: ${field}`);
                     }
                 } else {
                     // Handle direct match fields (like completed, winnerName)
                     match[field] = value;
                 }
             }
             // Optional: Mark changes as unsaved
             // hasUnsavedBracketChanges = true;
             // console.log("Current match state after input:", JSON.parse(JSON.stringify(currentBracketData.rounds[roundIndex].matches[matchIndex]))); // Can be very noisy

        } catch (error) {
             console.error("Error updating state from input:", error, { roundIndex, matchIndex, field });
        }
        // Note: We are *not* calling renderBracketEditor() on every input for performance.
        // The UI input element already reflects the change. The state is updated behind the scenes.
        // Re-rendering only happens on structural changes (add/delete round/match).
     }
    function deleteBracketRoundFromState(roundIndex) { /* ... existing code ... */
        console.log(`Attempting to delete round index: ${roundIndex} from state`);
         if (!currentBracketData.rounds || roundIndex < 0 || roundIndex >= currentBracketData.rounds.length) {
             console.error(`Invalid round index ${roundIndex} for deletion from state.`);
             alert(`Error: Cannot delete round ${roundIndex + 1} - index out of bounds.`);
             return;
         }
         const roundNameToDelete = currentBracketData.rounds[roundIndex]?.name || `Round ${roundIndex + 1}`;
         if (confirm(`Are you sure you want to delete "${roundNameToDelete}"? This will also delete all matches within it. This change is temporary until saved.`)) {
             // Remove the round from the state array
             currentBracketData.rounds.splice(roundIndex, 1);
             console.log(`Removed round index: ${roundIndex} from state. New state has ${currentBracketData.rounds.length} rounds.`);
             renderBracketEditor(); // Re-render UI from updated state
             // Optional: Mark changes as unsaved
             // hasUnsavedBracketChanges = true;
         } else {
             console.log("Deletion of round cancelled.");
         }
     }
    function addBracketMatchToState(roundIndex) { /* ... existing code ... */
        console.log(`Attempting to add match to round index: ${roundIndex} in state`);
         if (!currentBracketData || !currentBracketData.rounds || roundIndex < 0 || roundIndex >= currentBracketData.rounds.length) {
             console.error(`Invalid round index ${roundIndex} for adding match to state.`);
             alert(`Error: Cannot add match - could not find Round ${roundIndex + 1} in the data.`);
             return;
         }

         // Ensure the matches array exists for this round
         if (!Array.isArray(currentBracketData.rounds[roundIndex].matches)) {
             console.warn(`Matches array missing for round ${roundIndex}. Initializing.`);
             currentBracketData.rounds[roundIndex].matches = [];
         }

         // Add a new default match object to the specific round in the state
         const newMatch = {
             team1: { name: '', score: null },
             team2: { name: '', score: null },
             winnerName: '', // Use empty string for consistency with text inputs
             winner: null,   // Determined on save
             completed: false
         };
         currentBracketData.rounds[roundIndex].matches.push(newMatch);
         const newMatchIndex = currentBracketData.rounds[roundIndex].matches.length - 1;
         console.log(`Added new match (index ${newMatchIndex}) to round ${roundIndex} in state.`);
         renderBracketEditor(); // Re-render UI from state
         // Optional: Mark changes as unsaved
         // hasUnsavedBracketChanges = true;

         // Optional: Scroll to the new match or focus its first input
         // (Might require waiting for render to complete and finding the element)
         // setTimeout(() => {
         //     const newMatchElement = bracketEditor.querySelector(`.bracket-match-editor[data-round-index="${roundIndex}"][data-match-index="${newMatchIndex}"] input`);
         //     newMatchElement?.focus();
         // }, 100); // Small delay for render
    }
    function deleteBracketMatchFromState(roundIndex, matchIndex) { /* ... existing code ... */
        console.log(`Attempting to delete match index ${matchIndex} from round index ${roundIndex} from state.`);
         // Validate indices and state structure
         if (!currentBracketData || !currentBracketData.rounds || roundIndex < 0 || roundIndex >= currentBracketData.rounds.length ||
             !currentBracketData.rounds[roundIndex].matches || !Array.isArray(currentBracketData.rounds[roundIndex].matches) ||
             matchIndex < 0 || matchIndex >= currentBracketData.rounds[roundIndex].matches.length)
         {
             console.error(`Invalid indices R${roundIndex} M${matchIndex} or invalid data structure for deletion from state.`);
             alert(`Error: Could not find Match ${matchIndex + 1} in Round ${roundIndex + 1} to delete.`);
             return;
         }

        const roundName = currentBracketData.rounds[roundIndex]?.name || `Round ${roundIndex + 1}`;
        if (confirm(`Are you sure you want to delete Match ${matchIndex + 1} from "${roundName}"? This change is temporary until saved.`)) {
            // Remove the match from the state array
            currentBracketData.rounds[roundIndex].matches.splice(matchIndex, 1);
             console.log(`Removed match R${roundIndex} M${matchIndex} from state. Round ${roundIndex} now has ${currentBracketData.rounds[roundIndex].matches.length} matches.`);
            renderBracketEditor(); // Re-render UI from updated state
             // Optional: Mark changes as unsaved
             // hasUnsavedBracketChanges = true;
        } else {
            console.log("Deletion of match cancelled.");
        }
    }

    // --- General Save Status ---
    function showSaveStatus(message, isError = false) { /* ... existing code ... */
        console.log(`Save Status: ${message} (Error: ${isError})`);
        if (!saveStatus) { console.warn("showSaveStatus: saveStatus element not found."); return; } // Safety check
        saveStatus.textContent = message;
        saveStatus.style.color = isError ? 'red' : 'lightgreen';
        saveStatus.style.fontWeight = isError ? 'bold' : 'normal';

         // Clear any previous timeout
         if (window.saveStatusTimeout) clearTimeout(window.saveStatusTimeout);

         // Set a new timeout to clear the message
         window.saveStatusTimeout = setTimeout(() => {
             if (saveStatus.textContent === message) { // Only clear if the message hasn't changed
                 saveStatus.textContent = '';
                 saveStatus.style.color = 'lightgreen'; // Reset color
                 saveStatus.style.fontWeight = 'normal';
             }
         }, isError ? 8000 : 5000); // Show errors slightly longer
     }


    // --- Initial Load Call ---
    console.log("Admin script initialized. Waiting for authentication state...");

    // Add listeners for DOMContentLoaded and potentially window unload for cleanup
    document.addEventListener('DOMContentLoaded', () => {
         console.log("DOM Content Loaded. Initializing UI elements if possible.");
         // Initial data load and presence setup is handled by onAuthStateChanged
         // Attach static listeners that don't depend on dynamic content
         // (e.g., login button, if it were always visible)
         // Login button listener is already attached directly.
    });

    // Attempt to clean up presence on window close/refresh - BEST EFFORT ONLY
    window.addEventListener('beforeunload', async (event) => {
         // This is unreliable, especially on mobile or if the browser crashes.
         // The timestamp mechanism is the primary way to handle stale presence.
        if (currentUserId && auth.currentUser) {
            console.log("beforeunload triggered. Attempting quick presence removal (may not complete).");
             // We cannot use async/await reliably here.
             // Fire-and-forget deletion attempt.
             db.collection(PRESENCE_COLLECTION).doc(currentUserId).delete()
                 .then(() => console.log("Presence remove request sent on beforeunload."))
                 .catch(err => console.warn("Error sending presence remove on beforeunload:", err));

             // Standard requires returning nothing or a string for a confirmation dialog (which we don't want here)
             // delete event.returnValue; // Not needed if we don't set it
        }
    });


    // --- END OF SCRIPT --- //
</script>

</body>
</html>
